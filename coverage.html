
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>models: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sports-dynamics/cricket-fever/internal/db/models/boil_queries.go (100.0%)</option>
				
				<option value="file1">github.com/sports-dynamics/cricket-fever/internal/db/models/boil_types.go (35.5%)</option>
				
				<option value="file2">github.com/sports-dynamics/cricket-fever/internal/db/models/cricket_players.go (55.7%)</option>
				
				<option value="file3">github.com/sports-dynamics/cricket-fever/internal/db/models/cricket_teams.go (64.5%)</option>
				
				<option value="file4">github.com/sports-dynamics/cricket-fever/internal/db/models/migrations.go (63.1%)</option>
				
				<option value="file5">github.com/sports-dynamics/cricket-fever/internal/db/models/psql_upsert.go (96.3%)</option>
				
				<option value="file6">github.com/sports-dynamics/cricket-fever/internal/db/models/team_players.go (49.1%)</option>
				
				<option value="file7">github.com/sports-dynamics/cricket-fever/internal/handlers/errors.go (82.8%)</option>
				
				<option value="file8">github.com/sports-dynamics/cricket-fever/internal/handlers/heartbeat.go (83.3%)</option>
				
				<option value="file9">github.com/sports-dynamics/cricket-fever/internal/handlers/response.go (66.7%)</option>
				
				<option value="file10">github.com/sports-dynamics/cricket-fever/internal/middleware/auth.go (100.0%)</option>
				
				<option value="file11">github.com/sports-dynamics/cricket-fever/internal/players/models.go (100.0%)</option>
				
				<option value="file12">github.com/sports-dynamics/cricket-fever/internal/players/player_create_handler.go (58.8%)</option>
				
				<option value="file13">github.com/sports-dynamics/cricket-fever/internal/players/player_delete_handler.go (0.0%)</option>
				
				<option value="file14">github.com/sports-dynamics/cricket-fever/internal/players/player_get_handler.go (0.0%)</option>
				
				<option value="file15">github.com/sports-dynamics/cricket-fever/internal/players/player_update_handler.go (0.0%)</option>
				
				<option value="file16">github.com/sports-dynamics/cricket-fever/internal/players/repo.go (0.0%)</option>
				
				<option value="file17">github.com/sports-dynamics/cricket-fever/internal/players/service.go (0.0%)</option>
				
				<option value="file18">github.com/sports-dynamics/cricket-fever/internal/players/stubs.go (16.7%)</option>
				
				<option value="file19">github.com/sports-dynamics/cricket-fever/internal/validation/app_error.go (88.9%)</option>
				
				<option value="file20">github.com/sports-dynamics/cricket-fever/internal/validation/mulit_error.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "regexp"

        "github.com/volatiletech/sqlboiler/v4/drivers"
        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

var dialect = drivers.Dialect{
        LQ: 0x22,
        RQ: 0x22,

        UseIndexPlaceholders:    true,
        UseLastInsertID:         false,
        UseSchema:               false,
        UseDefaultKeyword:       true,
        UseAutoColumns:          false,
        UseTopClause:            false,
        UseOutputClause:         false,
        UseCaseWhenExistsClause: false,
}

// This is a dummy variable to prevent unused regexp import error
var _ = &amp;regexp.Regexp{}

// NewQuery initializes a new Query using the passed in QueryMods
func NewQuery(mods ...qm.QueryMod) *queries.Query <span class="cov8" title="1">{
        q := &amp;queries.Query{}
        queries.SetDialect(q, &amp;dialect)
        qm.Apply(q, mods...)

        return q
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "strconv"

        "github.com/friendsofgo/errors"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/strmangle"
)

// M type is for providing columns and column values to UpdateAll.
type M map[string]interface{}

// ErrSyncFail occurs during insert when the record could not be retrieved in
// order to populate default value information. This usually happens when LastInsertId
// fails or there was a primary key configuration that was not resolvable.
var ErrSyncFail = errors.New("models: failed to synchronize data after insert")

type insertCache struct {
        query        string
        retQuery     string
        valueMapping []uint64
        retMapping   []uint64
}

type updateCache struct {
        query        string
        valueMapping []uint64
}

func makeCacheKey(cols boil.Columns, nzDefaults []string) string <span class="cov8" title="1">{
        buf := strmangle.GetBuffer()

        buf.WriteString(strconv.Itoa(cols.Kind))
        for _, w := range cols.Cols </span><span class="cov8" title="1">{
                buf.WriteString(w)
        }</span>

        <span class="cov8" title="1">if len(nzDefaults) != 0 </span><span class="cov8" title="1">{
                buf.WriteByte('.')
        }</span>
        <span class="cov8" title="1">for _, nz := range nzDefaults </span><span class="cov8" title="1">{
                buf.WriteString(nz)
        }</span>

        <span class="cov8" title="1">str := buf.String()
        strmangle.PutBuffer(buf)
        return str</span>
}

type CricketRole string

// Enum values for CricketRole
const (
        CricketRoleBatsman           CricketRole = "Batsman"
        CricketRoleBowler            CricketRole = "Bowler"
        CricketRoleBatsmanAllRounder CricketRole = "Batsman AllRounder"
        CricketRoleBowlingAllRounder CricketRole = "Bowling AllRounder"
        CricketRoleWicketKeeper      CricketRole = "Wicket Keeper"
)

func AllCricketRole() []CricketRole <span class="cov0" title="0">{
        return []CricketRole{
                CricketRoleBatsman,
                CricketRoleBowler,
                CricketRoleBatsmanAllRounder,
                CricketRoleBowlingAllRounder,
                CricketRoleWicketKeeper,
        }
}</span>

func (e CricketRole) IsValid() error <span class="cov0" title="0">{
        switch e </span>{
        case CricketRoleBatsman, CricketRoleBowler, CricketRoleBatsmanAllRounder, CricketRoleBowlingAllRounder, CricketRoleWicketKeeper:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("enum is not valid")</span>
        }
}

func (e CricketRole) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

type CricketBattingPosition string

// Enum values for CricketBattingPosition
const (
        CricketBattingPositionOpeningBatsman   CricketBattingPosition = "Opening Batsman"
        CricketBattingPositionTopOrder         CricketBattingPosition = "Top Order"
        CricketBattingPositionMiddleOrder      CricketBattingPosition = "Middle Order"
        CricketBattingPositionLowerMiddleOrder CricketBattingPosition = "Lower Middle Order"
        CricketBattingPositionTailender        CricketBattingPosition = "Tailender"
)

func AllCricketBattingPosition() []CricketBattingPosition <span class="cov0" title="0">{
        return []CricketBattingPosition{
                CricketBattingPositionOpeningBatsman,
                CricketBattingPositionTopOrder,
                CricketBattingPositionMiddleOrder,
                CricketBattingPositionLowerMiddleOrder,
                CricketBattingPositionTailender,
        }
}</span>

func (e CricketBattingPosition) IsValid() error <span class="cov0" title="0">{
        switch e </span>{
        case CricketBattingPositionOpeningBatsman, CricketBattingPositionTopOrder, CricketBattingPositionMiddleOrder, CricketBattingPositionLowerMiddleOrder, CricketBattingPositionTailender:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("enum is not valid")</span>
        }
}

func (e CricketBattingPosition) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

type CricketBowlerType string

// Enum values for CricketBowlerType
const (
        CricketBowlerTypeFastBowler       CricketBowlerType = "Fast Bowler"
        CricketBowlerTypeMediumFastBowler CricketBowlerType = "Medium Fast Bowler"
        CricketBowlerTypeMediumPacer      CricketBowlerType = "Medium Pacer"
        CricketBowlerTypeSpinBowler       CricketBowlerType = "Spin Bowler"
        CricketBowlerTypeLegSpinner       CricketBowlerType = "Leg Spinner"
        CricketBowlerTypeOFFSpinner       CricketBowlerType = "Off Spinner"
        CricketBowlerTypeChinaMen         CricketBowlerType = "ChinaMen"
)

func AllCricketBowlerType() []CricketBowlerType <span class="cov0" title="0">{
        return []CricketBowlerType{
                CricketBowlerTypeFastBowler,
                CricketBowlerTypeMediumFastBowler,
                CricketBowlerTypeMediumPacer,
                CricketBowlerTypeSpinBowler,
                CricketBowlerTypeLegSpinner,
                CricketBowlerTypeOFFSpinner,
                CricketBowlerTypeChinaMen,
        }
}</span>

func (e CricketBowlerType) IsValid() error <span class="cov0" title="0">{
        switch e </span>{
        case CricketBowlerTypeFastBowler, CricketBowlerTypeMediumFastBowler, CricketBowlerTypeMediumPacer, CricketBowlerTypeSpinBowler, CricketBowlerTypeLegSpinner, CricketBowlerTypeOFFSpinner, CricketBowlerTypeChinaMen:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("enum is not valid")</span>
        }
}

func (e CricketBowlerType) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

type CricketFieldingPosition string

// Enum values for CricketFieldingPosition
const (
        CricketFieldingPositionSlip          CricketFieldingPosition = "Slip"
        CricketFieldingPositionGully         CricketFieldingPosition = "Gully"
        CricketFieldingPositionThirdMan      CricketFieldingPosition = "Third Man"
        CricketFieldingPositionFineLeg       CricketFieldingPosition = "Fine Leg"
        CricketFieldingPositionDeepSquareLeg CricketFieldingPosition = "Deep Square Leg"
        CricketFieldingPositionDeepMidwicket CricketFieldingPosition = "Deep Midwicket"
        CricketFieldingPositionLongON        CricketFieldingPosition = "Long On"
        CricketFieldingPositionLongOFF       CricketFieldingPosition = "Long Off"
        CricketFieldingPositionCover         CricketFieldingPosition = "Cover"
        CricketFieldingPositionExtraCover    CricketFieldingPosition = "Extra Cover"
        CricketFieldingPositionPoint         CricketFieldingPosition = "Point"
        CricketFieldingPositionSquareLeg     CricketFieldingPosition = "Square Leg"
        CricketFieldingPositionMidON         CricketFieldingPosition = "Mid On"
        CricketFieldingPositionMidOFF        CricketFieldingPosition = "Mid Off"
        CricketFieldingPositionMidwicket     CricketFieldingPosition = "Midwicket"
        CricketFieldingPositionShortLeg      CricketFieldingPosition = "Short Leg"
        CricketFieldingPositionLegSlip       CricketFieldingPosition = "Leg Slip"
        CricketFieldingPositionShortFineLeg  CricketFieldingPosition = "Short Fine Leg"
)

func AllCricketFieldingPosition() []CricketFieldingPosition <span class="cov0" title="0">{
        return []CricketFieldingPosition{
                CricketFieldingPositionSlip,
                CricketFieldingPositionGully,
                CricketFieldingPositionThirdMan,
                CricketFieldingPositionFineLeg,
                CricketFieldingPositionDeepSquareLeg,
                CricketFieldingPositionDeepMidwicket,
                CricketFieldingPositionLongON,
                CricketFieldingPositionLongOFF,
                CricketFieldingPositionCover,
                CricketFieldingPositionExtraCover,
                CricketFieldingPositionPoint,
                CricketFieldingPositionSquareLeg,
                CricketFieldingPositionMidON,
                CricketFieldingPositionMidOFF,
                CricketFieldingPositionMidwicket,
                CricketFieldingPositionShortLeg,
                CricketFieldingPositionLegSlip,
                CricketFieldingPositionShortFineLeg,
        }
}</span>

func (e CricketFieldingPosition) IsValid() error <span class="cov0" title="0">{
        switch e </span>{
        case CricketFieldingPositionSlip, CricketFieldingPositionGully, CricketFieldingPositionThirdMan, CricketFieldingPositionFineLeg, CricketFieldingPositionDeepSquareLeg, CricketFieldingPositionDeepMidwicket, CricketFieldingPositionLongON, CricketFieldingPositionLongOFF, CricketFieldingPositionCover, CricketFieldingPositionExtraCover, CricketFieldingPositionPoint, CricketFieldingPositionSquareLeg, CricketFieldingPositionMidON, CricketFieldingPositionMidOFF, CricketFieldingPositionMidwicket, CricketFieldingPositionShortLeg, CricketFieldingPositionLegSlip, CricketFieldingPositionShortFineLeg:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("enum is not valid")</span>
        }
}

func (e CricketFieldingPosition) String() string <span class="cov0" title="0">{
        return string(e)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "context"
        "database/sql"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/friendsofgo/errors"
        "github.com/volatiletech/null/v8"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
        "github.com/volatiletech/strmangle"
)

// CricketPlayer is an object representing the database table.
type CricketPlayer struct {
        PlayerID          int                     `boil:"player_id" json:"player_id" toml:"player_id" yaml:"player_id"`
        PlayerName        string                  `boil:"player_name" json:"player_name" toml:"player_name" yaml:"player_name"`
        PlayerEmail       string                  `boil:"player_email" json:"player_email" toml:"player_email" yaml:"player_email"`
        PlayerMobile      int                     `boil:"player_mobile" json:"player_mobile" toml:"player_mobile" yaml:"player_mobile"`
        PlayerPicture     null.Bytes              `boil:"player_picture" json:"player_picture,omitempty" toml:"player_picture" yaml:"player_picture,omitempty"`
        PlayerRole        CricketRole             `boil:"player_role" json:"player_role" toml:"player_role" yaml:"player_role"`
        BattingPositions  CricketBattingPosition  `boil:"batting_positions" json:"batting_positions" toml:"batting_positions" yaml:"batting_positions"`
        BowlerTypes       CricketBowlerType       `boil:"bowler_types" json:"bowler_types" toml:"bowler_types" yaml:"bowler_types"`
        FieldingPositions CricketFieldingPosition `boil:"fielding_positions" json:"fielding_positions" toml:"fielding_positions" yaml:"fielding_positions"`

        R *cricketPlayerR `boil:"-" json:"-" toml:"-" yaml:"-"`
        L cricketPlayerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CricketPlayerColumns = struct {
        PlayerID          string
        PlayerName        string
        PlayerEmail       string
        PlayerMobile      string
        PlayerPicture     string
        PlayerRole        string
        BattingPositions  string
        BowlerTypes       string
        FieldingPositions string
}{
        PlayerID:          "player_id",
        PlayerName:        "player_name",
        PlayerEmail:       "player_email",
        PlayerMobile:      "player_mobile",
        PlayerPicture:     "player_picture",
        PlayerRole:        "player_role",
        BattingPositions:  "batting_positions",
        BowlerTypes:       "bowler_types",
        FieldingPositions: "fielding_positions",
}

var CricketPlayerTableColumns = struct {
        PlayerID          string
        PlayerName        string
        PlayerEmail       string
        PlayerMobile      string
        PlayerPicture     string
        PlayerRole        string
        BattingPositions  string
        BowlerTypes       string
        FieldingPositions string
}{
        PlayerID:          "cricket_players.player_id",
        PlayerName:        "cricket_players.player_name",
        PlayerEmail:       "cricket_players.player_email",
        PlayerMobile:      "cricket_players.player_mobile",
        PlayerPicture:     "cricket_players.player_picture",
        PlayerRole:        "cricket_players.player_role",
        BattingPositions:  "cricket_players.batting_positions",
        BowlerTypes:       "cricket_players.bowler_types",
        FieldingPositions: "cricket_players.fielding_positions",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.EQ, x) }</span>
func (w whereHelperint) NEQ(x int) qm.QueryMod <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.NEQ, x) }</span>
func (w whereHelperint) LT(x int) qm.QueryMod  <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LT, x) }</span>
func (w whereHelperint) LTE(x int) qm.QueryMod <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LTE, x) }</span>
func (w whereHelperint) GT(x int) qm.QueryMod  <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GT, x) }</span>
func (w whereHelperint) GTE(x int) qm.QueryMod <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GTE, x) }</span>
func (w whereHelperint) IN(slice []int) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod     <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.EQ, x) }</span>
func (w whereHelperstring) NEQ(x string) qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.NEQ, x) }</span>
func (w whereHelperstring) LT(x string) qm.QueryMod     <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LT, x) }</span>
func (w whereHelperstring) LTE(x string) qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LTE, x) }</span>
func (w whereHelperstring) GT(x string) qm.QueryMod     <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GT, x) }</span>
func (w whereHelperstring) GTE(x string) qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GTE, x) }</span>
func (w whereHelperstring) LIKE(x string) qm.QueryMod   <span class="cov0" title="0">{ return qm.Where(w.field+" LIKE ?", x) }</span>
func (w whereHelperstring) NLIKE(x string) qm.QueryMod  <span class="cov0" title="0">{ return qm.Where(w.field+" NOT LIKE ?", x) }</span>
func (w whereHelperstring) ILIKE(x string) qm.QueryMod  <span class="cov0" title="0">{ return qm.Where(w.field+" ILIKE ?", x) }</span>
func (w whereHelperstring) NILIKE(x string) qm.QueryMod <span class="cov0" title="0">{ return qm.Where(w.field+" NOT ILIKE ?", x) }</span>
func (w whereHelperstring) IN(slice []string) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

type whereHelpernull_Bytes struct{ field string }

func (w whereHelpernull_Bytes) EQ(x null.Bytes) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, false, x)
}</span>
func (w whereHelpernull_Bytes) NEQ(x null.Bytes) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, true, x)
}</span>
func (w whereHelpernull_Bytes) LT(x null.Bytes) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelpernull_Bytes) LTE(x null.Bytes) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelpernull_Bytes) GT(x null.Bytes) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelpernull_Bytes) GTE(x null.Bytes) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>

func (w whereHelpernull_Bytes) IsNull() qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.WhereIsNull(w.field) }</span>
func (w whereHelpernull_Bytes) IsNotNull() qm.QueryMod <span class="cov0" title="0">{ return qmhelper.WhereIsNotNull(w.field) }</span>

type whereHelperCricketRole struct{ field string }

func (w whereHelperCricketRole) EQ(x CricketRole) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.EQ, x)
}</span>
func (w whereHelperCricketRole) NEQ(x CricketRole) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.NEQ, x)
}</span>
func (w whereHelperCricketRole) LT(x CricketRole) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelperCricketRole) LTE(x CricketRole) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelperCricketRole) GT(x CricketRole) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelperCricketRole) GTE(x CricketRole) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>
func (w whereHelperCricketRole) IN(slice []CricketRole) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelperCricketRole) NIN(slice []CricketRole) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

type whereHelperCricketBattingPosition struct{ field string }

func (w whereHelperCricketBattingPosition) EQ(x CricketBattingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.EQ, x)
}</span>
func (w whereHelperCricketBattingPosition) NEQ(x CricketBattingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.NEQ, x)
}</span>
func (w whereHelperCricketBattingPosition) LT(x CricketBattingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelperCricketBattingPosition) LTE(x CricketBattingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelperCricketBattingPosition) GT(x CricketBattingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelperCricketBattingPosition) GTE(x CricketBattingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>
func (w whereHelperCricketBattingPosition) IN(slice []CricketBattingPosition) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelperCricketBattingPosition) NIN(slice []CricketBattingPosition) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

type whereHelperCricketBowlerType struct{ field string }

func (w whereHelperCricketBowlerType) EQ(x CricketBowlerType) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.EQ, x)
}</span>
func (w whereHelperCricketBowlerType) NEQ(x CricketBowlerType) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.NEQ, x)
}</span>
func (w whereHelperCricketBowlerType) LT(x CricketBowlerType) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelperCricketBowlerType) LTE(x CricketBowlerType) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelperCricketBowlerType) GT(x CricketBowlerType) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelperCricketBowlerType) GTE(x CricketBowlerType) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>
func (w whereHelperCricketBowlerType) IN(slice []CricketBowlerType) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelperCricketBowlerType) NIN(slice []CricketBowlerType) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

type whereHelperCricketFieldingPosition struct{ field string }

func (w whereHelperCricketFieldingPosition) EQ(x CricketFieldingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.EQ, x)
}</span>
func (w whereHelperCricketFieldingPosition) NEQ(x CricketFieldingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.NEQ, x)
}</span>
func (w whereHelperCricketFieldingPosition) LT(x CricketFieldingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelperCricketFieldingPosition) LTE(x CricketFieldingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelperCricketFieldingPosition) GT(x CricketFieldingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelperCricketFieldingPosition) GTE(x CricketFieldingPosition) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>
func (w whereHelperCricketFieldingPosition) IN(slice []CricketFieldingPosition) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelperCricketFieldingPosition) NIN(slice []CricketFieldingPosition) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

var CricketPlayerWhere = struct {
        PlayerID          whereHelperint
        PlayerName        whereHelperstring
        PlayerEmail       whereHelperstring
        PlayerMobile      whereHelperint
        PlayerPicture     whereHelpernull_Bytes
        PlayerRole        whereHelperCricketRole
        BattingPositions  whereHelperCricketBattingPosition
        BowlerTypes       whereHelperCricketBowlerType
        FieldingPositions whereHelperCricketFieldingPosition
}{
        PlayerID:          whereHelperint{field: "\"cricket_players\".\"player_id\""},
        PlayerName:        whereHelperstring{field: "\"cricket_players\".\"player_name\""},
        PlayerEmail:       whereHelperstring{field: "\"cricket_players\".\"player_email\""},
        PlayerMobile:      whereHelperint{field: "\"cricket_players\".\"player_mobile\""},
        PlayerPicture:     whereHelpernull_Bytes{field: "\"cricket_players\".\"player_picture\""},
        PlayerRole:        whereHelperCricketRole{field: "\"cricket_players\".\"player_role\""},
        BattingPositions:  whereHelperCricketBattingPosition{field: "\"cricket_players\".\"batting_positions\""},
        BowlerTypes:       whereHelperCricketBowlerType{field: "\"cricket_players\".\"bowler_types\""},
        FieldingPositions: whereHelperCricketFieldingPosition{field: "\"cricket_players\".\"fielding_positions\""},
}

// CricketPlayerRels is where relationship names are stored.
var CricketPlayerRels = struct {
        PlayerTeamPlayers string
}{
        PlayerTeamPlayers: "PlayerTeamPlayers",
}

// cricketPlayerR is where relationships are stored.
type cricketPlayerR struct {
        PlayerTeamPlayers TeamPlayerSlice `boil:"PlayerTeamPlayers" json:"PlayerTeamPlayers" toml:"PlayerTeamPlayers" yaml:"PlayerTeamPlayers"`
}

// NewStruct creates a new relationship struct
func (*cricketPlayerR) NewStruct() *cricketPlayerR <span class="cov0" title="0">{
        return &amp;cricketPlayerR{}
}</span>

func (r *cricketPlayerR) GetPlayerTeamPlayers() TeamPlayerSlice <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.PlayerTeamPlayers</span>
}

// cricketPlayerL is where Load methods for each relationship are stored.
type cricketPlayerL struct{}

var (
        cricketPlayerAllColumns            = []string{"player_id", "player_name", "player_email", "player_mobile", "player_picture", "player_role", "batting_positions", "bowler_types", "fielding_positions"}
        cricketPlayerColumnsWithoutDefault = []string{"player_name", "player_email", "player_mobile", "player_role", "batting_positions", "bowler_types", "fielding_positions"}
        cricketPlayerColumnsWithDefault    = []string{"player_id", "player_picture"}
        cricketPlayerPrimaryKeyColumns     = []string{"player_id"}
        cricketPlayerGeneratedColumns      = []string{}
)

type (
        // CricketPlayerSlice is an alias for a slice of pointers to CricketPlayer.
        // This should almost always be used instead of []CricketPlayer.
        CricketPlayerSlice []*CricketPlayer
        // CricketPlayerHook is the signature for custom CricketPlayer hook methods
        CricketPlayerHook func(context.Context, boil.ContextExecutor, *CricketPlayer) error

        cricketPlayerQuery struct {
                *queries.Query
        }
)

// Cache for insert, update and upsert
var (
        cricketPlayerType                 = reflect.TypeOf(&amp;CricketPlayer{})
        cricketPlayerMapping              = queries.MakeStructMapping(cricketPlayerType)
        cricketPlayerPrimaryKeyMapping, _ = queries.BindMapping(cricketPlayerType, cricketPlayerMapping, cricketPlayerPrimaryKeyColumns)
        cricketPlayerInsertCacheMut       sync.RWMutex
        cricketPlayerInsertCache          = make(map[string]insertCache)
        cricketPlayerUpdateCacheMut       sync.RWMutex
        cricketPlayerUpdateCache          = make(map[string]updateCache)
        cricketPlayerUpsertCacheMut       sync.RWMutex
        cricketPlayerUpsertCache          = make(map[string]insertCache)
)

var (
        // Force time package dependency for automated UpdatedAt/CreatedAt.
        _ = time.Second
        // Force qmhelper dependency for where clause generation (which doesn't
        // always happen)
        _ = qmhelper.Where
)

var cricketPlayerAfterSelectHooks []CricketPlayerHook

var cricketPlayerBeforeInsertHooks []CricketPlayerHook
var cricketPlayerAfterInsertHooks []CricketPlayerHook

var cricketPlayerBeforeUpdateHooks []CricketPlayerHook
var cricketPlayerAfterUpdateHooks []CricketPlayerHook

var cricketPlayerBeforeDeleteHooks []CricketPlayerHook
var cricketPlayerAfterDeleteHooks []CricketPlayerHook

var cricketPlayerBeforeUpsertHooks []CricketPlayerHook
var cricketPlayerAfterUpsertHooks []CricketPlayerHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CricketPlayer) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketPlayerAfterSelectHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CricketPlayer) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketPlayerBeforeInsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CricketPlayer) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketPlayerAfterInsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CricketPlayer) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketPlayerBeforeUpdateHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CricketPlayer) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketPlayerAfterUpdateHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CricketPlayer) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketPlayerBeforeDeleteHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CricketPlayer) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketPlayerAfterDeleteHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CricketPlayer) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketPlayerBeforeUpsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CricketPlayer) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketPlayerAfterUpsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// AddCricketPlayerHook registers your hook function for all future operations.
func AddCricketPlayerHook(hookPoint boil.HookPoint, cricketPlayerHook CricketPlayerHook) <span class="cov8" title="1">{
        switch hookPoint </span>{
        case boil.AfterSelectHook:<span class="cov8" title="1">
                cricketPlayerAfterSelectHooks = append(cricketPlayerAfterSelectHooks, cricketPlayerHook)</span>
        case boil.BeforeInsertHook:<span class="cov8" title="1">
                cricketPlayerBeforeInsertHooks = append(cricketPlayerBeforeInsertHooks, cricketPlayerHook)</span>
        case boil.AfterInsertHook:<span class="cov8" title="1">
                cricketPlayerAfterInsertHooks = append(cricketPlayerAfterInsertHooks, cricketPlayerHook)</span>
        case boil.BeforeUpdateHook:<span class="cov8" title="1">
                cricketPlayerBeforeUpdateHooks = append(cricketPlayerBeforeUpdateHooks, cricketPlayerHook)</span>
        case boil.AfterUpdateHook:<span class="cov8" title="1">
                cricketPlayerAfterUpdateHooks = append(cricketPlayerAfterUpdateHooks, cricketPlayerHook)</span>
        case boil.BeforeDeleteHook:<span class="cov8" title="1">
                cricketPlayerBeforeDeleteHooks = append(cricketPlayerBeforeDeleteHooks, cricketPlayerHook)</span>
        case boil.AfterDeleteHook:<span class="cov8" title="1">
                cricketPlayerAfterDeleteHooks = append(cricketPlayerAfterDeleteHooks, cricketPlayerHook)</span>
        case boil.BeforeUpsertHook:<span class="cov8" title="1">
                cricketPlayerBeforeUpsertHooks = append(cricketPlayerBeforeUpsertHooks, cricketPlayerHook)</span>
        case boil.AfterUpsertHook:<span class="cov8" title="1">
                cricketPlayerAfterUpsertHooks = append(cricketPlayerAfterUpsertHooks, cricketPlayerHook)</span>
        }
}

// OneG returns a single cricketPlayer record from the query using the global executor.
func (q cricketPlayerQuery) OneG(ctx context.Context) (*CricketPlayer, error) <span class="cov0" title="0">{
        return q.One(ctx, boil.GetContextDB())
}</span>

// One returns a single cricketPlayer record from the query.
func (q cricketPlayerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CricketPlayer, error) <span class="cov8" title="1">{
        o := &amp;CricketPlayer{}

        queries.SetLimit(q.Query, 1)

        err := q.Bind(ctx, exec, o)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: failed to execute a one query for cricket_players")</span>
        }

        <span class="cov8" title="1">if err := o.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return o, err
        }</span>

        <span class="cov8" title="1">return o, nil</span>
}

// AllG returns all CricketPlayer records from the query using the global executor.
func (q cricketPlayerQuery) AllG(ctx context.Context) (CricketPlayerSlice, error) <span class="cov0" title="0">{
        return q.All(ctx, boil.GetContextDB())
}</span>

// All returns all CricketPlayer records from the query.
func (q cricketPlayerQuery) All(ctx context.Context, exec boil.ContextExecutor) (CricketPlayerSlice, error) <span class="cov8" title="1">{
        var o []*CricketPlayer

        err := q.Bind(ctx, exec, &amp;o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "models: failed to assign all query results to CricketPlayer slice")
        }</span>

        <span class="cov8" title="1">if len(cricketPlayerAfterSelectHooks) != 0 </span><span class="cov8" title="1">{
                for _, obj := range o </span><span class="cov8" title="1">{
                        if err := obj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return o, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return o, nil</span>
}

// CountG returns the count of all CricketPlayer records in the query using the global executor
func (q cricketPlayerQuery) CountG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return q.Count(ctx, boil.GetContextDB())
}</span>

// Count returns the count of all CricketPlayer records in the query.
func (q cricketPlayerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to count cricket_players rows")
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// ExistsG checks if the row exists in the table using the global executor.
func (q cricketPlayerQuery) ExistsG(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return q.Exists(ctx, boil.GetContextDB())
}</span>

// Exists checks if the row exists in the table.
func (q cricketPlayerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)
        queries.SetLimit(q.Query, 1)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: failed to check if cricket_players exists")
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// PlayerTeamPlayers retrieves all the team_player's TeamPlayers with an executor via player_id column.
func (o *CricketPlayer) PlayerTeamPlayers(mods ...qm.QueryMod) teamPlayerQuery <span class="cov8" title="1">{
        var queryMods []qm.QueryMod
        if len(mods) != 0 </span><span class="cov0" title="0">{
                queryMods = append(queryMods, mods...)
        }</span>

        <span class="cov8" title="1">queryMods = append(queryMods,
                qm.Where("\"team_players\".\"player_id\"=?", o.PlayerID),
        )

        return TeamPlayers(queryMods...)</span>
}

// LoadPlayerTeamPlayers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (cricketPlayerL) LoadPlayerTeamPlayers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCricketPlayer interface{}, mods queries.Applicator) error <span class="cov8" title="1">{
        var slice []*CricketPlayer
        var object *CricketPlayer

        if singular </span><span class="cov8" title="1">{
                var ok bool
                object, ok = maybeCricketPlayer.(*CricketPlayer)
                if !ok </span><span class="cov0" title="0">{
                        object = new(CricketPlayer)
                        ok = queries.SetFromEmbeddedStruct(&amp;object, &amp;maybeCricketPlayer)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCricketPlayer))
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                s, ok := maybeCricketPlayer.(*[]*CricketPlayer)
                if ok </span><span class="cov8" title="1">{
                        slice = *s
                }</span> else<span class="cov0" title="0"> {
                        ok = queries.SetFromEmbeddedStruct(&amp;slice, maybeCricketPlayer)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCricketPlayer))
                        }</span>
                }
        }

        <span class="cov8" title="1">args := make([]interface{}, 0, 1)
        if singular </span><span class="cov8" title="1">{
                if object.R == nil </span><span class="cov0" title="0">{
                        object.R = &amp;cricketPlayerR{}
                }</span>
                <span class="cov8" title="1">args = append(args, object.PlayerID)</span>
        } else<span class="cov8" title="1"> {
        Outer:
                for _, obj := range slice </span><span class="cov8" title="1">{
                        if obj.R == nil </span><span class="cov8" title="1">{
                                obj.R = &amp;cricketPlayerR{}
                        }</span>

                        <span class="cov8" title="1">for _, a := range args </span><span class="cov0" title="0">{
                                if a == obj.PlayerID </span><span class="cov0" title="0">{
                                        continue Outer</span>
                                }
                        }

                        <span class="cov8" title="1">args = append(args, obj.PlayerID)</span>
                }
        }

        <span class="cov8" title="1">if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">query := NewQuery(
                qm.From(`team_players`),
                qm.WhereIn(`team_players.player_id in ?`, args...),
        )
        if mods != nil </span><span class="cov0" title="0">{
                mods.Apply(query)
        }</span>

        <span class="cov8" title="1">results, err := query.QueryContext(ctx, e)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to eager load team_players")
        }</span>

        <span class="cov8" title="1">var resultSlice []*TeamPlayer
        if err = queries.Bind(results, &amp;resultSlice); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to bind eager loaded slice team_players")
        }</span>

        <span class="cov8" title="1">if err = results.Close(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to close results in eager load on team_players")
        }</span>
        <span class="cov8" title="1">if err = results.Err(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error occurred during iteration of eager loaded relations for team_players")
        }</span>

        <span class="cov8" title="1">if len(teamPlayerAfterSelectHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range resultSlice </span><span class="cov0" title="0">{
                        if err := obj.doAfterSelectHooks(ctx, e); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">if singular </span><span class="cov8" title="1">{
                object.R.PlayerTeamPlayers = resultSlice
                for _, foreign := range resultSlice </span><span class="cov8" title="1">{
                        if foreign.R == nil </span><span class="cov8" title="1">{
                                foreign.R = &amp;teamPlayerR{}
                        }</span>
                        <span class="cov8" title="1">foreign.R.Player = object</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">for _, foreign := range resultSlice </span><span class="cov8" title="1">{
                for _, local := range slice </span><span class="cov8" title="1">{
                        if local.PlayerID == foreign.PlayerID </span><span class="cov8" title="1">{
                                local.R.PlayerTeamPlayers = append(local.R.PlayerTeamPlayers, foreign)
                                if foreign.R == nil </span><span class="cov8" title="1">{
                                        foreign.R = &amp;teamPlayerR{}
                                }</span>
                                <span class="cov8" title="1">foreign.R.Player = local
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// AddPlayerTeamPlayersG adds the given related objects to the existing relationships
// of the cricket_player, optionally inserting them as new records.
// Appends related to o.R.PlayerTeamPlayers.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *CricketPlayer) AddPlayerTeamPlayersG(ctx context.Context, insert bool, related ...*TeamPlayer) error <span class="cov0" title="0">{
        return o.AddPlayerTeamPlayers(ctx, boil.GetContextDB(), insert, related...)
}</span>

// AddPlayerTeamPlayers adds the given related objects to the existing relationships
// of the cricket_player, optionally inserting them as new records.
// Appends related to o.R.PlayerTeamPlayers.
// Sets related.R.Player appropriately.
func (o *CricketPlayer) AddPlayerTeamPlayers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TeamPlayer) error <span class="cov8" title="1">{
        var err error
        for _, rel := range related </span><span class="cov8" title="1">{
                if insert </span><span class="cov8" title="1">{
                        rel.PlayerID = o.PlayerID
                        if err = rel.Insert(ctx, exec, boil.Infer()); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to insert into foreign table")
                        }</span>
                } else<span class="cov8" title="1"> {
                        updateQuery := fmt.Sprintf(
                                "UPDATE \"team_players\" SET %s WHERE %s",
                                strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
                                strmangle.WhereClause("\"", "\"", 2, teamPlayerPrimaryKeyColumns),
                        )
                        values := []interface{}{o.PlayerID, rel.PlayerID, rel.TeamID, rel.JoiningDate}

                        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                                writer := boil.DebugWriterFrom(ctx)
                                fmt.Fprintln(writer, updateQuery)
                                fmt.Fprintln(writer, values)
                        }</span>
                        <span class="cov8" title="1">if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to update foreign table")
                        }</span>

                        <span class="cov8" title="1">rel.PlayerID = o.PlayerID</span>
                }
        }

        <span class="cov8" title="1">if o.R == nil </span><span class="cov8" title="1">{
                o.R = &amp;cricketPlayerR{
                        PlayerTeamPlayers: related,
                }
        }</span> else<span class="cov8" title="1"> {
                o.R.PlayerTeamPlayers = append(o.R.PlayerTeamPlayers, related...)
        }</span>

        <span class="cov8" title="1">for _, rel := range related </span><span class="cov8" title="1">{
                if rel.R == nil </span><span class="cov8" title="1">{
                        rel.R = &amp;teamPlayerR{
                                Player: o,
                        }
                }</span> else<span class="cov0" title="0"> {
                        rel.R.Player = o
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// CricketPlayers retrieves all the records using an executor.
func CricketPlayers(mods ...qm.QueryMod) cricketPlayerQuery <span class="cov8" title="1">{
        mods = append(mods, qm.From("\"cricket_players\""))
        q := NewQuery(mods...)
        if len(queries.GetSelect(q)) == 0 </span><span class="cov8" title="1">{
                queries.SetSelect(q, []string{"\"cricket_players\".*"})
        }</span>

        <span class="cov8" title="1">return cricketPlayerQuery{q}</span>
}

// FindCricketPlayerG retrieves a single record by ID.
func FindCricketPlayerG(ctx context.Context, playerID int, selectCols ...string) (*CricketPlayer, error) <span class="cov0" title="0">{
        return FindCricketPlayer(ctx, boil.GetContextDB(), playerID, selectCols...)
}</span>

// FindCricketPlayer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCricketPlayer(ctx context.Context, exec boil.ContextExecutor, playerID int, selectCols ...string) (*CricketPlayer, error) <span class="cov8" title="1">{
        cricketPlayerObj := &amp;CricketPlayer{}

        sel := "*"
        if len(selectCols) &gt; 0 </span><span class="cov0" title="0">{
                sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf(
                "select %s from \"cricket_players\" where \"player_id\"=$1", sel,
        )

        q := queries.Raw(query, playerID)

        err := q.Bind(ctx, exec, cricketPlayerObj)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: unable to select from cricket_players")</span>
        }

        <span class="cov8" title="1">if err = cricketPlayerObj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return cricketPlayerObj, err
        }</span>

        <span class="cov8" title="1">return cricketPlayerObj, nil</span>
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *CricketPlayer) InsertG(ctx context.Context, columns boil.Columns) error <span class="cov0" title="0">{
        return o.Insert(ctx, boil.GetContextDB(), columns)
}</span>

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CricketPlayer) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no cricket_players provided for insertion")
        }</span>

        <span class="cov8" title="1">var err error

        if err := o.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nzDefaults := queries.NonZeroDefaultSet(cricketPlayerColumnsWithDefault, o)

        key := makeCacheKey(columns, nzDefaults)
        cricketPlayerInsertCacheMut.RLock()
        cache, cached := cricketPlayerInsertCache[key]
        cricketPlayerInsertCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl, returnColumns := columns.InsertColumnSet(
                        cricketPlayerAllColumns,
                        cricketPlayerColumnsWithDefault,
                        cricketPlayerColumnsWithoutDefault,
                        nzDefaults,
                )

                cache.valueMapping, err = queries.BindMapping(cricketPlayerType, cricketPlayerMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cache.retMapping, err = queries.BindMapping(cricketPlayerType, cricketPlayerMapping, returnColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(wl) != 0 </span><span class="cov8" title="1">{
                        cache.query = fmt.Sprintf("INSERT INTO \"cricket_players\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
                }</span> else<span class="cov0" title="0"> {
                        cache.query = "INSERT INTO \"cricket_players\" %sDEFAULT VALUES%s"
                }</span>

                <span class="cov8" title="1">var queryOutput, queryReturning string

                if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                        queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)</span>
        }

        <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov8" title="1">if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
        }</span> else<span class="cov0" title="0"> {
                _, err = exec.ExecContext(ctx, cache.query, vals...)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to insert into cricket_players")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                cricketPlayerInsertCacheMut.Lock()
                cricketPlayerInsertCache[key] = cache
                cricketPlayerInsertCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return o.doAfterInsertHooks(ctx, exec)</span>
}

// UpdateG a single CricketPlayer record using the global executor.
// See Update for more documentation.
func (o *CricketPlayer) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        return o.Update(ctx, boil.GetContextDB(), columns)
}</span>

// Update uses an executor to update the CricketPlayer.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CricketPlayer) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov8" title="1">{
        var err error
        if err = o.doBeforeUpdateHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">key := makeCacheKey(columns, nil)
        cricketPlayerUpdateCacheMut.RLock()
        cache, cached := cricketPlayerUpdateCache[key]
        cricketPlayerUpdateCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl := columns.UpdateColumnSet(
                        cricketPlayerAllColumns,
                        cricketPlayerPrimaryKeyColumns,
                )

                if !columns.IsWhitelist() </span><span class="cov8" title="1">{
                        wl = strmangle.SetComplement(wl, []string{"created_at"})
                }</span>
                <span class="cov8" title="1">if len(wl) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("models: unable to update cricket_players, could not build whitelist")
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf("UPDATE \"cricket_players\" SET %s WHERE %s",
                        strmangle.SetParamNames("\"", "\"", 1, wl),
                        strmangle.WhereClause("\"", "\"", len(wl)+1, cricketPlayerPrimaryKeyColumns),
                )
                cache.valueMapping, err = queries.BindMapping(cricketPlayerType, cricketPlayerMapping, append(wl, cricketPlayerPrimaryKeyColumns...))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, values)
        }</span>
        <span class="cov8" title="1">var result sql.Result
        result, err = exec.ExecContext(ctx, cache.query, values...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update cricket_players row")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by update for cricket_players")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                cricketPlayerUpdateCacheMut.Lock()
                cricketPlayerUpdateCache[key] = cache
                cricketPlayerUpdateCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return rowsAff, o.doAfterUpdateHooks(ctx, exec)</span>
}

// UpdateAllG updates all rows with the specified column values.
func (q cricketPlayerQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) <span class="cov0" title="0">{
        return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}</span>

// UpdateAll updates all rows with the specified column values.
func (q cricketPlayerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        queries.SetUpdate(q.Query, cols)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all for cricket_players")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected for cricket_players")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// UpdateAllG updates all rows with the specified column values.
func (o CricketPlayerSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) <span class="cov0" title="0">{
        return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}</span>

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CricketPlayerSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov8" title="1">{
        ln := int64(len(o))
        if ln == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if len(cols) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: update all requires at least one column argument")
        }</span>

        <span class="cov8" title="1">colNames := make([]string, len(cols))
        args := make([]interface{}, len(cols))

        i := 0
        for name, value := range cols </span><span class="cov8" title="1">{
                colNames[i] = name
                args[i] = value
                i++
        }</span>

        // Append all of the primary key values for each column
        <span class="cov8" title="1">for _, obj := range o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cricketPlayerPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := fmt.Sprintf("UPDATE \"cricket_players\" SET %s WHERE %s",
                strmangle.SetParamNames("\"", "\"", 1, colNames),
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, cricketPlayerPrimaryKeyColumns, len(o)))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all in cricketPlayer slice")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all cricketPlayer")
        }</span>
        <span class="cov8" title="1">return rowsAff, nil</span>
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *CricketPlayer) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error <span class="cov0" title="0">{
        return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}</span>

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CricketPlayer) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no cricket_players provided for upsert")
        }</span>

        <span class="cov8" title="1">if err := o.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nzDefaults := queries.NonZeroDefaultSet(cricketPlayerColumnsWithDefault, o)

        // Build cache key in-line uglily - mysql vs psql problems
        buf := strmangle.GetBuffer()
        if updateOnConflict </span><span class="cov8" title="1">{
                buf.WriteByte('t')
        }</span> else<span class="cov8" title="1"> {
                buf.WriteByte('f')
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        for _, c := range conflictColumns </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(updateColumns.Kind))
        for _, c := range updateColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(insertColumns.Kind))
        for _, c := range insertColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        for _, c := range nzDefaults </span><span class="cov8" title="1">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">key := buf.String()
        strmangle.PutBuffer(buf)

        cricketPlayerUpsertCacheMut.RLock()
        cache, cached := cricketPlayerUpsertCache[key]
        cricketPlayerUpsertCacheMut.RUnlock()

        var err error

        if !cached </span><span class="cov8" title="1">{
                insert, ret := insertColumns.InsertColumnSet(
                        cricketPlayerAllColumns,
                        cricketPlayerColumnsWithDefault,
                        cricketPlayerColumnsWithoutDefault,
                        nzDefaults,
                )

                update := updateColumns.UpdateColumnSet(
                        cricketPlayerAllColumns,
                        cricketPlayerPrimaryKeyColumns,
                )

                if updateOnConflict &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                        return errors.New("models: unable to upsert cricket_players, could not build update column list")
                }</span>

                <span class="cov8" title="1">conflict := conflictColumns
                if len(conflict) == 0 </span><span class="cov8" title="1">{
                        conflict = make([]string, len(cricketPlayerPrimaryKeyColumns))
                        copy(conflict, cricketPlayerPrimaryKeyColumns)
                }</span>
                <span class="cov8" title="1">cache.query = buildUpsertQueryPostgres(dialect, "\"cricket_players\"", updateOnConflict, ret, update, conflict, insert)

                cache.valueMapping, err = queries.BindMapping(cricketPlayerType, cricketPlayerMapping, insert)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(ret) != 0 </span><span class="cov8" title="1">{
                        cache.retMapping, err = queries.BindMapping(cricketPlayerType, cricketPlayerMapping, ret)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)
        var returns []interface{}
        if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                returns = queries.PtrsFromMapping(value, cache.retMapping)
        }</span>

        <span class="cov8" title="1">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov8" title="1">if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = nil // Postgres doesn't return anything when there's no update
                }</span>
        } else<span class="cov8" title="1"> {
                _, err = exec.ExecContext(ctx, cache.query, vals...)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to upsert cricket_players")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                cricketPlayerUpsertCacheMut.Lock()
                cricketPlayerUpsertCache[key] = cache
                cricketPlayerUpsertCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return o.doAfterUpsertHooks(ctx, exec)</span>
}

// DeleteG deletes a single CricketPlayer record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *CricketPlayer) DeleteG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return o.Delete(ctx, boil.GetContextDB())
}</span>

// Delete deletes a single CricketPlayer record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CricketPlayer) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no CricketPlayer provided for delete")
        }</span>

        <span class="cov8" title="1">if err := o.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cricketPlayerPrimaryKeyMapping)
        sql := "DELETE FROM \"cricket_players\" WHERE \"player_id\"=$1"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete from cricket_players")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by delete for cricket_players")
        }</span>

        <span class="cov8" title="1">if err := o.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return rowsAff, nil</span>
}

func (q cricketPlayerQuery) DeleteAllG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return q.DeleteAll(ctx, boil.GetContextDB())
}</span>

// DeleteAll deletes all matching rows.
func (q cricketPlayerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if q.Query == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no cricketPlayerQuery provided for delete all")
        }</span>

        <span class="cov8" title="1">queries.SetDelete(q.Query)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from cricket_players")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cricket_players")
        }</span>

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// DeleteAllG deletes all rows in the slice.
func (o CricketPlayerSlice) DeleteAllG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return o.DeleteAll(ctx, boil.GetContextDB())
}</span>

// DeleteAll deletes all rows in the slice, using an executor.
func (o CricketPlayerSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if len(cricketPlayerBeforeDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov8" title="1">var args []interface{}
        for _, obj := range o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cricketPlayerPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := "DELETE FROM \"cricket_players\" WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cricketPlayerPrimaryKeyColumns, len(o))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from cricketPlayer slice")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cricket_players")
        }</span>

        <span class="cov8" title="1">if len(cricketPlayerAfterDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// ReloadG refetches the object from the database using the primary keys.
func (o *CricketPlayer) ReloadG(ctx context.Context) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no CricketPlayer provided for reload")
        }</span>

        <span class="cov0" title="0">return o.Reload(ctx, boil.GetContextDB())</span>
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CricketPlayer) Reload(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        ret, err := FindCricketPlayer(ctx, exec, o.PlayerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*o = *ret
        return nil</span>
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CricketPlayerSlice) ReloadAllG(ctx context.Context) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: empty CricketPlayerSlice provided for reload all")
        }</span>

        <span class="cov0" title="0">return o.ReloadAll(ctx, boil.GetContextDB())</span>
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CricketPlayerSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        if o == nil || len(*o) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">slice := CricketPlayerSlice{}
        var args []interface{}
        for _, obj := range *o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cricketPlayerPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := "SELECT \"cricket_players\".* FROM \"cricket_players\" WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cricketPlayerPrimaryKeyColumns, len(*o))

        q := queries.Raw(sql, args...)

        err := q.Bind(ctx, exec, &amp;slice)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to reload all in CricketPlayerSlice")
        }</span>

        <span class="cov8" title="1">*o = slice

        return nil</span>
}

// CricketPlayerExistsG checks if the CricketPlayer row exists.
func CricketPlayerExistsG(ctx context.Context, playerID int) (bool, error) <span class="cov0" title="0">{
        return CricketPlayerExists(ctx, boil.GetContextDB(), playerID)
}</span>

// CricketPlayerExists checks if the CricketPlayer row exists.
func CricketPlayerExists(ctx context.Context, exec boil.ContextExecutor, playerID int) (bool, error) <span class="cov8" title="1">{
        var exists bool
        sql := "select exists(select 1 from \"cricket_players\" where \"player_id\"=$1 limit 1)"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, playerID)
        }</span>
        <span class="cov8" title="1">row := exec.QueryRowContext(ctx, sql, playerID)

        err := row.Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: unable to check if cricket_players exists")
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// Exists checks if the CricketPlayer row exists.
func (o *CricketPlayer) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        return CricketPlayerExists(ctx, exec, o.PlayerID)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "context"
        "database/sql"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/friendsofgo/errors"
        "github.com/volatiletech/null/v8"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
        "github.com/volatiletech/strmangle"
)

// CricketTeam is an object representing the database table.
type CricketTeam struct {
        TeamID        int      `boil:"team_id" json:"team_id" toml:"team_id" yaml:"team_id"`
        TeamUUID      string   `boil:"team_uuid" json:"team_uuid" toml:"team_uuid" yaml:"team_uuid"`
        TeamName      string   `boil:"team_name" json:"team_name" toml:"team_name" yaml:"team_name"`
        TeamCountry   string   `boil:"team_country" json:"team_country" toml:"team_country" yaml:"team_country"`
        TeamState     string   `boil:"team_state" json:"team_state" toml:"team_state" yaml:"team_state"`
        TeamCity      string   `boil:"team_city" json:"team_city" toml:"team_city" yaml:"team_city"`
        CaptainID     null.Int `boil:"captain_id" json:"captain_id,omitempty" toml:"captain_id" yaml:"captain_id,omitempty"`
        ViceCaptainID null.Int `boil:"vice_captain_id" json:"vice_captain_id,omitempty" toml:"vice_captain_id" yaml:"vice_captain_id,omitempty"`
        TeamCoachID   null.Int `boil:"team_coach_id" json:"team_coach_id,omitempty" toml:"team_coach_id" yaml:"team_coach_id,omitempty"`

        R *cricketTeamR `boil:"-" json:"-" toml:"-" yaml:"-"`
        L cricketTeamL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CricketTeamColumns = struct {
        TeamID        string
        TeamUUID      string
        TeamName      string
        TeamCountry   string
        TeamState     string
        TeamCity      string
        CaptainID     string
        ViceCaptainID string
        TeamCoachID   string
}{
        TeamID:        "team_id",
        TeamUUID:      "team_uuid",
        TeamName:      "team_name",
        TeamCountry:   "team_country",
        TeamState:     "team_state",
        TeamCity:      "team_city",
        CaptainID:     "captain_id",
        ViceCaptainID: "vice_captain_id",
        TeamCoachID:   "team_coach_id",
}

var CricketTeamTableColumns = struct {
        TeamID        string
        TeamUUID      string
        TeamName      string
        TeamCountry   string
        TeamState     string
        TeamCity      string
        CaptainID     string
        ViceCaptainID string
        TeamCoachID   string
}{
        TeamID:        "cricket_teams.team_id",
        TeamUUID:      "cricket_teams.team_uuid",
        TeamName:      "cricket_teams.team_name",
        TeamCountry:   "cricket_teams.team_country",
        TeamState:     "cricket_teams.team_state",
        TeamCity:      "cricket_teams.team_city",
        CaptainID:     "cricket_teams.captain_id",
        ViceCaptainID: "cricket_teams.vice_captain_id",
        TeamCoachID:   "cricket_teams.team_coach_id",
}

// Generated where

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, false, x)
}</span>
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, true, x)
}</span>
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.WhereIsNull(w.field) }</span>
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod <span class="cov0" title="0">{ return qmhelper.WhereIsNotNull(w.field) }</span>

var CricketTeamWhere = struct {
        TeamID        whereHelperint
        TeamUUID      whereHelperstring
        TeamName      whereHelperstring
        TeamCountry   whereHelperstring
        TeamState     whereHelperstring
        TeamCity      whereHelperstring
        CaptainID     whereHelpernull_Int
        ViceCaptainID whereHelpernull_Int
        TeamCoachID   whereHelpernull_Int
}{
        TeamID:        whereHelperint{field: "\"cricket_teams\".\"team_id\""},
        TeamUUID:      whereHelperstring{field: "\"cricket_teams\".\"team_uuid\""},
        TeamName:      whereHelperstring{field: "\"cricket_teams\".\"team_name\""},
        TeamCountry:   whereHelperstring{field: "\"cricket_teams\".\"team_country\""},
        TeamState:     whereHelperstring{field: "\"cricket_teams\".\"team_state\""},
        TeamCity:      whereHelperstring{field: "\"cricket_teams\".\"team_city\""},
        CaptainID:     whereHelpernull_Int{field: "\"cricket_teams\".\"captain_id\""},
        ViceCaptainID: whereHelpernull_Int{field: "\"cricket_teams\".\"vice_captain_id\""},
        TeamCoachID:   whereHelpernull_Int{field: "\"cricket_teams\".\"team_coach_id\""},
}

// CricketTeamRels is where relationship names are stored.
var CricketTeamRels = struct {
        TeamTeamPlayers string
}{
        TeamTeamPlayers: "TeamTeamPlayers",
}

// cricketTeamR is where relationships are stored.
type cricketTeamR struct {
        TeamTeamPlayers TeamPlayerSlice `boil:"TeamTeamPlayers" json:"TeamTeamPlayers" toml:"TeamTeamPlayers" yaml:"TeamTeamPlayers"`
}

// NewStruct creates a new relationship struct
func (*cricketTeamR) NewStruct() *cricketTeamR <span class="cov0" title="0">{
        return &amp;cricketTeamR{}
}</span>

func (r *cricketTeamR) GetTeamTeamPlayers() TeamPlayerSlice <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.TeamTeamPlayers</span>
}

// cricketTeamL is where Load methods for each relationship are stored.
type cricketTeamL struct{}

var (
        cricketTeamAllColumns            = []string{"team_id", "team_uuid", "team_name", "team_country", "team_state", "team_city", "captain_id", "vice_captain_id", "team_coach_id"}
        cricketTeamColumnsWithoutDefault = []string{"team_uuid", "team_name", "team_country", "team_state", "team_city"}
        cricketTeamColumnsWithDefault    = []string{"team_id", "captain_id", "vice_captain_id", "team_coach_id"}
        cricketTeamPrimaryKeyColumns     = []string{"team_id"}
        cricketTeamGeneratedColumns      = []string{}
)

type (
        // CricketTeamSlice is an alias for a slice of pointers to CricketTeam.
        // This should almost always be used instead of []CricketTeam.
        CricketTeamSlice []*CricketTeam
        // CricketTeamHook is the signature for custom CricketTeam hook methods
        CricketTeamHook func(context.Context, boil.ContextExecutor, *CricketTeam) error

        cricketTeamQuery struct {
                *queries.Query
        }
)

// Cache for insert, update and upsert
var (
        cricketTeamType                 = reflect.TypeOf(&amp;CricketTeam{})
        cricketTeamMapping              = queries.MakeStructMapping(cricketTeamType)
        cricketTeamPrimaryKeyMapping, _ = queries.BindMapping(cricketTeamType, cricketTeamMapping, cricketTeamPrimaryKeyColumns)
        cricketTeamInsertCacheMut       sync.RWMutex
        cricketTeamInsertCache          = make(map[string]insertCache)
        cricketTeamUpdateCacheMut       sync.RWMutex
        cricketTeamUpdateCache          = make(map[string]updateCache)
        cricketTeamUpsertCacheMut       sync.RWMutex
        cricketTeamUpsertCache          = make(map[string]insertCache)
)

var (
        // Force time package dependency for automated UpdatedAt/CreatedAt.
        _ = time.Second
        // Force qmhelper dependency for where clause generation (which doesn't
        // always happen)
        _ = qmhelper.Where
)

var cricketTeamAfterSelectHooks []CricketTeamHook

var cricketTeamBeforeInsertHooks []CricketTeamHook
var cricketTeamAfterInsertHooks []CricketTeamHook

var cricketTeamBeforeUpdateHooks []CricketTeamHook
var cricketTeamAfterUpdateHooks []CricketTeamHook

var cricketTeamBeforeDeleteHooks []CricketTeamHook
var cricketTeamAfterDeleteHooks []CricketTeamHook

var cricketTeamBeforeUpsertHooks []CricketTeamHook
var cricketTeamAfterUpsertHooks []CricketTeamHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CricketTeam) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketTeamAfterSelectHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CricketTeam) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketTeamBeforeInsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CricketTeam) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketTeamAfterInsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CricketTeam) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketTeamBeforeUpdateHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CricketTeam) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketTeamAfterUpdateHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CricketTeam) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketTeamBeforeDeleteHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CricketTeam) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketTeamAfterDeleteHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CricketTeam) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketTeamBeforeUpsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CricketTeam) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range cricketTeamAfterUpsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// AddCricketTeamHook registers your hook function for all future operations.
func AddCricketTeamHook(hookPoint boil.HookPoint, cricketTeamHook CricketTeamHook) <span class="cov8" title="1">{
        switch hookPoint </span>{
        case boil.AfterSelectHook:<span class="cov8" title="1">
                cricketTeamAfterSelectHooks = append(cricketTeamAfterSelectHooks, cricketTeamHook)</span>
        case boil.BeforeInsertHook:<span class="cov8" title="1">
                cricketTeamBeforeInsertHooks = append(cricketTeamBeforeInsertHooks, cricketTeamHook)</span>
        case boil.AfterInsertHook:<span class="cov8" title="1">
                cricketTeamAfterInsertHooks = append(cricketTeamAfterInsertHooks, cricketTeamHook)</span>
        case boil.BeforeUpdateHook:<span class="cov8" title="1">
                cricketTeamBeforeUpdateHooks = append(cricketTeamBeforeUpdateHooks, cricketTeamHook)</span>
        case boil.AfterUpdateHook:<span class="cov8" title="1">
                cricketTeamAfterUpdateHooks = append(cricketTeamAfterUpdateHooks, cricketTeamHook)</span>
        case boil.BeforeDeleteHook:<span class="cov8" title="1">
                cricketTeamBeforeDeleteHooks = append(cricketTeamBeforeDeleteHooks, cricketTeamHook)</span>
        case boil.AfterDeleteHook:<span class="cov8" title="1">
                cricketTeamAfterDeleteHooks = append(cricketTeamAfterDeleteHooks, cricketTeamHook)</span>
        case boil.BeforeUpsertHook:<span class="cov8" title="1">
                cricketTeamBeforeUpsertHooks = append(cricketTeamBeforeUpsertHooks, cricketTeamHook)</span>
        case boil.AfterUpsertHook:<span class="cov8" title="1">
                cricketTeamAfterUpsertHooks = append(cricketTeamAfterUpsertHooks, cricketTeamHook)</span>
        }
}

// OneG returns a single cricketTeam record from the query using the global executor.
func (q cricketTeamQuery) OneG(ctx context.Context) (*CricketTeam, error) <span class="cov0" title="0">{
        return q.One(ctx, boil.GetContextDB())
}</span>

// One returns a single cricketTeam record from the query.
func (q cricketTeamQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CricketTeam, error) <span class="cov8" title="1">{
        o := &amp;CricketTeam{}

        queries.SetLimit(q.Query, 1)

        err := q.Bind(ctx, exec, o)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: failed to execute a one query for cricket_teams")</span>
        }

        <span class="cov8" title="1">if err := o.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return o, err
        }</span>

        <span class="cov8" title="1">return o, nil</span>
}

// AllG returns all CricketTeam records from the query using the global executor.
func (q cricketTeamQuery) AllG(ctx context.Context) (CricketTeamSlice, error) <span class="cov0" title="0">{
        return q.All(ctx, boil.GetContextDB())
}</span>

// All returns all CricketTeam records from the query.
func (q cricketTeamQuery) All(ctx context.Context, exec boil.ContextExecutor) (CricketTeamSlice, error) <span class="cov8" title="1">{
        var o []*CricketTeam

        err := q.Bind(ctx, exec, &amp;o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "models: failed to assign all query results to CricketTeam slice")
        }</span>

        <span class="cov8" title="1">if len(cricketTeamAfterSelectHooks) != 0 </span><span class="cov8" title="1">{
                for _, obj := range o </span><span class="cov8" title="1">{
                        if err := obj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return o, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return o, nil</span>
}

// CountG returns the count of all CricketTeam records in the query using the global executor
func (q cricketTeamQuery) CountG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return q.Count(ctx, boil.GetContextDB())
}</span>

// Count returns the count of all CricketTeam records in the query.
func (q cricketTeamQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to count cricket_teams rows")
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// ExistsG checks if the row exists in the table using the global executor.
func (q cricketTeamQuery) ExistsG(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return q.Exists(ctx, boil.GetContextDB())
}</span>

// Exists checks if the row exists in the table.
func (q cricketTeamQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)
        queries.SetLimit(q.Query, 1)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: failed to check if cricket_teams exists")
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// TeamTeamPlayers retrieves all the team_player's TeamPlayers with an executor via team_id column.
func (o *CricketTeam) TeamTeamPlayers(mods ...qm.QueryMod) teamPlayerQuery <span class="cov8" title="1">{
        var queryMods []qm.QueryMod
        if len(mods) != 0 </span><span class="cov0" title="0">{
                queryMods = append(queryMods, mods...)
        }</span>

        <span class="cov8" title="1">queryMods = append(queryMods,
                qm.Where("\"team_players\".\"team_id\"=?", o.TeamID),
        )

        return TeamPlayers(queryMods...)</span>
}

// LoadTeamTeamPlayers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (cricketTeamL) LoadTeamTeamPlayers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCricketTeam interface{}, mods queries.Applicator) error <span class="cov8" title="1">{
        var slice []*CricketTeam
        var object *CricketTeam

        if singular </span><span class="cov8" title="1">{
                var ok bool
                object, ok = maybeCricketTeam.(*CricketTeam)
                if !ok </span><span class="cov0" title="0">{
                        object = new(CricketTeam)
                        ok = queries.SetFromEmbeddedStruct(&amp;object, &amp;maybeCricketTeam)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCricketTeam))
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                s, ok := maybeCricketTeam.(*[]*CricketTeam)
                if ok </span><span class="cov8" title="1">{
                        slice = *s
                }</span> else<span class="cov0" title="0"> {
                        ok = queries.SetFromEmbeddedStruct(&amp;slice, maybeCricketTeam)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCricketTeam))
                        }</span>
                }
        }

        <span class="cov8" title="1">args := make([]interface{}, 0, 1)
        if singular </span><span class="cov8" title="1">{
                if object.R == nil </span><span class="cov0" title="0">{
                        object.R = &amp;cricketTeamR{}
                }</span>
                <span class="cov8" title="1">args = append(args, object.TeamID)</span>
        } else<span class="cov8" title="1"> {
        Outer:
                for _, obj := range slice </span><span class="cov8" title="1">{
                        if obj.R == nil </span><span class="cov8" title="1">{
                                obj.R = &amp;cricketTeamR{}
                        }</span>

                        <span class="cov8" title="1">for _, a := range args </span><span class="cov0" title="0">{
                                if a == obj.TeamID </span><span class="cov0" title="0">{
                                        continue Outer</span>
                                }
                        }

                        <span class="cov8" title="1">args = append(args, obj.TeamID)</span>
                }
        }

        <span class="cov8" title="1">if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">query := NewQuery(
                qm.From(`team_players`),
                qm.WhereIn(`team_players.team_id in ?`, args...),
        )
        if mods != nil </span><span class="cov0" title="0">{
                mods.Apply(query)
        }</span>

        <span class="cov8" title="1">results, err := query.QueryContext(ctx, e)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to eager load team_players")
        }</span>

        <span class="cov8" title="1">var resultSlice []*TeamPlayer
        if err = queries.Bind(results, &amp;resultSlice); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to bind eager loaded slice team_players")
        }</span>

        <span class="cov8" title="1">if err = results.Close(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to close results in eager load on team_players")
        }</span>
        <span class="cov8" title="1">if err = results.Err(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error occurred during iteration of eager loaded relations for team_players")
        }</span>

        <span class="cov8" title="1">if len(teamPlayerAfterSelectHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range resultSlice </span><span class="cov0" title="0">{
                        if err := obj.doAfterSelectHooks(ctx, e); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">if singular </span><span class="cov8" title="1">{
                object.R.TeamTeamPlayers = resultSlice
                for _, foreign := range resultSlice </span><span class="cov8" title="1">{
                        if foreign.R == nil </span><span class="cov8" title="1">{
                                foreign.R = &amp;teamPlayerR{}
                        }</span>
                        <span class="cov8" title="1">foreign.R.Team = object</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">for _, foreign := range resultSlice </span><span class="cov8" title="1">{
                for _, local := range slice </span><span class="cov8" title="1">{
                        if local.TeamID == foreign.TeamID </span><span class="cov8" title="1">{
                                local.R.TeamTeamPlayers = append(local.R.TeamTeamPlayers, foreign)
                                if foreign.R == nil </span><span class="cov8" title="1">{
                                        foreign.R = &amp;teamPlayerR{}
                                }</span>
                                <span class="cov8" title="1">foreign.R.Team = local
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// AddTeamTeamPlayersG adds the given related objects to the existing relationships
// of the cricket_team, optionally inserting them as new records.
// Appends related to o.R.TeamTeamPlayers.
// Sets related.R.Team appropriately.
// Uses the global database handle.
func (o *CricketTeam) AddTeamTeamPlayersG(ctx context.Context, insert bool, related ...*TeamPlayer) error <span class="cov0" title="0">{
        return o.AddTeamTeamPlayers(ctx, boil.GetContextDB(), insert, related...)
}</span>

// AddTeamTeamPlayers adds the given related objects to the existing relationships
// of the cricket_team, optionally inserting them as new records.
// Appends related to o.R.TeamTeamPlayers.
// Sets related.R.Team appropriately.
func (o *CricketTeam) AddTeamTeamPlayers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TeamPlayer) error <span class="cov8" title="1">{
        var err error
        for _, rel := range related </span><span class="cov8" title="1">{
                if insert </span><span class="cov8" title="1">{
                        rel.TeamID = o.TeamID
                        if err = rel.Insert(ctx, exec, boil.Infer()); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to insert into foreign table")
                        }</span>
                } else<span class="cov8" title="1"> {
                        updateQuery := fmt.Sprintf(
                                "UPDATE \"team_players\" SET %s WHERE %s",
                                strmangle.SetParamNames("\"", "\"", 1, []string{"team_id"}),
                                strmangle.WhereClause("\"", "\"", 2, teamPlayerPrimaryKeyColumns),
                        )
                        values := []interface{}{o.TeamID, rel.PlayerID, rel.TeamID, rel.JoiningDate}

                        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                                writer := boil.DebugWriterFrom(ctx)
                                fmt.Fprintln(writer, updateQuery)
                                fmt.Fprintln(writer, values)
                        }</span>
                        <span class="cov8" title="1">if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to update foreign table")
                        }</span>

                        <span class="cov8" title="1">rel.TeamID = o.TeamID</span>
                }
        }

        <span class="cov8" title="1">if o.R == nil </span><span class="cov8" title="1">{
                o.R = &amp;cricketTeamR{
                        TeamTeamPlayers: related,
                }
        }</span> else<span class="cov8" title="1"> {
                o.R.TeamTeamPlayers = append(o.R.TeamTeamPlayers, related...)
        }</span>

        <span class="cov8" title="1">for _, rel := range related </span><span class="cov8" title="1">{
                if rel.R == nil </span><span class="cov8" title="1">{
                        rel.R = &amp;teamPlayerR{
                                Team: o,
                        }
                }</span> else<span class="cov0" title="0"> {
                        rel.R.Team = o
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// CricketTeams retrieves all the records using an executor.
func CricketTeams(mods ...qm.QueryMod) cricketTeamQuery <span class="cov8" title="1">{
        mods = append(mods, qm.From("\"cricket_teams\""))
        q := NewQuery(mods...)
        if len(queries.GetSelect(q)) == 0 </span><span class="cov8" title="1">{
                queries.SetSelect(q, []string{"\"cricket_teams\".*"})
        }</span>

        <span class="cov8" title="1">return cricketTeamQuery{q}</span>
}

// FindCricketTeamG retrieves a single record by ID.
func FindCricketTeamG(ctx context.Context, teamID int, selectCols ...string) (*CricketTeam, error) <span class="cov0" title="0">{
        return FindCricketTeam(ctx, boil.GetContextDB(), teamID, selectCols...)
}</span>

// FindCricketTeam retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCricketTeam(ctx context.Context, exec boil.ContextExecutor, teamID int, selectCols ...string) (*CricketTeam, error) <span class="cov8" title="1">{
        cricketTeamObj := &amp;CricketTeam{}

        sel := "*"
        if len(selectCols) &gt; 0 </span><span class="cov0" title="0">{
                sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf(
                "select %s from \"cricket_teams\" where \"team_id\"=$1", sel,
        )

        q := queries.Raw(query, teamID)

        err := q.Bind(ctx, exec, cricketTeamObj)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: unable to select from cricket_teams")</span>
        }

        <span class="cov8" title="1">if err = cricketTeamObj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return cricketTeamObj, err
        }</span>

        <span class="cov8" title="1">return cricketTeamObj, nil</span>
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *CricketTeam) InsertG(ctx context.Context, columns boil.Columns) error <span class="cov0" title="0">{
        return o.Insert(ctx, boil.GetContextDB(), columns)
}</span>

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CricketTeam) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no cricket_teams provided for insertion")
        }</span>

        <span class="cov8" title="1">var err error

        if err := o.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nzDefaults := queries.NonZeroDefaultSet(cricketTeamColumnsWithDefault, o)

        key := makeCacheKey(columns, nzDefaults)
        cricketTeamInsertCacheMut.RLock()
        cache, cached := cricketTeamInsertCache[key]
        cricketTeamInsertCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl, returnColumns := columns.InsertColumnSet(
                        cricketTeamAllColumns,
                        cricketTeamColumnsWithDefault,
                        cricketTeamColumnsWithoutDefault,
                        nzDefaults,
                )

                cache.valueMapping, err = queries.BindMapping(cricketTeamType, cricketTeamMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cache.retMapping, err = queries.BindMapping(cricketTeamType, cricketTeamMapping, returnColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(wl) != 0 </span><span class="cov8" title="1">{
                        cache.query = fmt.Sprintf("INSERT INTO \"cricket_teams\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
                }</span> else<span class="cov0" title="0"> {
                        cache.query = "INSERT INTO \"cricket_teams\" %sDEFAULT VALUES%s"
                }</span>

                <span class="cov8" title="1">var queryOutput, queryReturning string

                if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                        queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)</span>
        }

        <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov8" title="1">if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
        }</span> else<span class="cov0" title="0"> {
                _, err = exec.ExecContext(ctx, cache.query, vals...)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to insert into cricket_teams")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                cricketTeamInsertCacheMut.Lock()
                cricketTeamInsertCache[key] = cache
                cricketTeamInsertCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return o.doAfterInsertHooks(ctx, exec)</span>
}

// UpdateG a single CricketTeam record using the global executor.
// See Update for more documentation.
func (o *CricketTeam) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        return o.Update(ctx, boil.GetContextDB(), columns)
}</span>

// Update uses an executor to update the CricketTeam.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CricketTeam) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov8" title="1">{
        var err error
        if err = o.doBeforeUpdateHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">key := makeCacheKey(columns, nil)
        cricketTeamUpdateCacheMut.RLock()
        cache, cached := cricketTeamUpdateCache[key]
        cricketTeamUpdateCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl := columns.UpdateColumnSet(
                        cricketTeamAllColumns,
                        cricketTeamPrimaryKeyColumns,
                )

                if !columns.IsWhitelist() </span><span class="cov8" title="1">{
                        wl = strmangle.SetComplement(wl, []string{"created_at"})
                }</span>
                <span class="cov8" title="1">if len(wl) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("models: unable to update cricket_teams, could not build whitelist")
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf("UPDATE \"cricket_teams\" SET %s WHERE %s",
                        strmangle.SetParamNames("\"", "\"", 1, wl),
                        strmangle.WhereClause("\"", "\"", len(wl)+1, cricketTeamPrimaryKeyColumns),
                )
                cache.valueMapping, err = queries.BindMapping(cricketTeamType, cricketTeamMapping, append(wl, cricketTeamPrimaryKeyColumns...))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, values)
        }</span>
        <span class="cov8" title="1">var result sql.Result
        result, err = exec.ExecContext(ctx, cache.query, values...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update cricket_teams row")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by update for cricket_teams")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                cricketTeamUpdateCacheMut.Lock()
                cricketTeamUpdateCache[key] = cache
                cricketTeamUpdateCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return rowsAff, o.doAfterUpdateHooks(ctx, exec)</span>
}

// UpdateAllG updates all rows with the specified column values.
func (q cricketTeamQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) <span class="cov0" title="0">{
        return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}</span>

// UpdateAll updates all rows with the specified column values.
func (q cricketTeamQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        queries.SetUpdate(q.Query, cols)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all for cricket_teams")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected for cricket_teams")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// UpdateAllG updates all rows with the specified column values.
func (o CricketTeamSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) <span class="cov0" title="0">{
        return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}</span>

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CricketTeamSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov8" title="1">{
        ln := int64(len(o))
        if ln == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if len(cols) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: update all requires at least one column argument")
        }</span>

        <span class="cov8" title="1">colNames := make([]string, len(cols))
        args := make([]interface{}, len(cols))

        i := 0
        for name, value := range cols </span><span class="cov8" title="1">{
                colNames[i] = name
                args[i] = value
                i++
        }</span>

        // Append all of the primary key values for each column
        <span class="cov8" title="1">for _, obj := range o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cricketTeamPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := fmt.Sprintf("UPDATE \"cricket_teams\" SET %s WHERE %s",
                strmangle.SetParamNames("\"", "\"", 1, colNames),
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, cricketTeamPrimaryKeyColumns, len(o)))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all in cricketTeam slice")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all cricketTeam")
        }</span>
        <span class="cov8" title="1">return rowsAff, nil</span>
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *CricketTeam) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error <span class="cov0" title="0">{
        return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}</span>

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CricketTeam) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no cricket_teams provided for upsert")
        }</span>

        <span class="cov8" title="1">if err := o.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nzDefaults := queries.NonZeroDefaultSet(cricketTeamColumnsWithDefault, o)

        // Build cache key in-line uglily - mysql vs psql problems
        buf := strmangle.GetBuffer()
        if updateOnConflict </span><span class="cov8" title="1">{
                buf.WriteByte('t')
        }</span> else<span class="cov8" title="1"> {
                buf.WriteByte('f')
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        for _, c := range conflictColumns </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(updateColumns.Kind))
        for _, c := range updateColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(insertColumns.Kind))
        for _, c := range insertColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        for _, c := range nzDefaults </span><span class="cov8" title="1">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">key := buf.String()
        strmangle.PutBuffer(buf)

        cricketTeamUpsertCacheMut.RLock()
        cache, cached := cricketTeamUpsertCache[key]
        cricketTeamUpsertCacheMut.RUnlock()

        var err error

        if !cached </span><span class="cov8" title="1">{
                insert, ret := insertColumns.InsertColumnSet(
                        cricketTeamAllColumns,
                        cricketTeamColumnsWithDefault,
                        cricketTeamColumnsWithoutDefault,
                        nzDefaults,
                )

                update := updateColumns.UpdateColumnSet(
                        cricketTeamAllColumns,
                        cricketTeamPrimaryKeyColumns,
                )

                if updateOnConflict &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                        return errors.New("models: unable to upsert cricket_teams, could not build update column list")
                }</span>

                <span class="cov8" title="1">conflict := conflictColumns
                if len(conflict) == 0 </span><span class="cov8" title="1">{
                        conflict = make([]string, len(cricketTeamPrimaryKeyColumns))
                        copy(conflict, cricketTeamPrimaryKeyColumns)
                }</span>
                <span class="cov8" title="1">cache.query = buildUpsertQueryPostgres(dialect, "\"cricket_teams\"", updateOnConflict, ret, update, conflict, insert)

                cache.valueMapping, err = queries.BindMapping(cricketTeamType, cricketTeamMapping, insert)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(ret) != 0 </span><span class="cov8" title="1">{
                        cache.retMapping, err = queries.BindMapping(cricketTeamType, cricketTeamMapping, ret)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)
        var returns []interface{}
        if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                returns = queries.PtrsFromMapping(value, cache.retMapping)
        }</span>

        <span class="cov8" title="1">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov8" title="1">if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = nil // Postgres doesn't return anything when there's no update
                }</span>
        } else<span class="cov8" title="1"> {
                _, err = exec.ExecContext(ctx, cache.query, vals...)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to upsert cricket_teams")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                cricketTeamUpsertCacheMut.Lock()
                cricketTeamUpsertCache[key] = cache
                cricketTeamUpsertCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return o.doAfterUpsertHooks(ctx, exec)</span>
}

// DeleteG deletes a single CricketTeam record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *CricketTeam) DeleteG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return o.Delete(ctx, boil.GetContextDB())
}</span>

// Delete deletes a single CricketTeam record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CricketTeam) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no CricketTeam provided for delete")
        }</span>

        <span class="cov8" title="1">if err := o.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cricketTeamPrimaryKeyMapping)
        sql := "DELETE FROM \"cricket_teams\" WHERE \"team_id\"=$1"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete from cricket_teams")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by delete for cricket_teams")
        }</span>

        <span class="cov8" title="1">if err := o.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return rowsAff, nil</span>
}

func (q cricketTeamQuery) DeleteAllG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return q.DeleteAll(ctx, boil.GetContextDB())
}</span>

// DeleteAll deletes all matching rows.
func (q cricketTeamQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if q.Query == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no cricketTeamQuery provided for delete all")
        }</span>

        <span class="cov8" title="1">queries.SetDelete(q.Query)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from cricket_teams")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cricket_teams")
        }</span>

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// DeleteAllG deletes all rows in the slice.
func (o CricketTeamSlice) DeleteAllG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return o.DeleteAll(ctx, boil.GetContextDB())
}</span>

// DeleteAll deletes all rows in the slice, using an executor.
func (o CricketTeamSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if len(cricketTeamBeforeDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov8" title="1">var args []interface{}
        for _, obj := range o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cricketTeamPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := "DELETE FROM \"cricket_teams\" WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cricketTeamPrimaryKeyColumns, len(o))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from cricketTeam slice")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cricket_teams")
        }</span>

        <span class="cov8" title="1">if len(cricketTeamAfterDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// ReloadG refetches the object from the database using the primary keys.
func (o *CricketTeam) ReloadG(ctx context.Context) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no CricketTeam provided for reload")
        }</span>

        <span class="cov0" title="0">return o.Reload(ctx, boil.GetContextDB())</span>
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CricketTeam) Reload(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        ret, err := FindCricketTeam(ctx, exec, o.TeamID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*o = *ret
        return nil</span>
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CricketTeamSlice) ReloadAllG(ctx context.Context) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: empty CricketTeamSlice provided for reload all")
        }</span>

        <span class="cov0" title="0">return o.ReloadAll(ctx, boil.GetContextDB())</span>
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CricketTeamSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        if o == nil || len(*o) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">slice := CricketTeamSlice{}
        var args []interface{}
        for _, obj := range *o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cricketTeamPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := "SELECT \"cricket_teams\".* FROM \"cricket_teams\" WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cricketTeamPrimaryKeyColumns, len(*o))

        q := queries.Raw(sql, args...)

        err := q.Bind(ctx, exec, &amp;slice)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to reload all in CricketTeamSlice")
        }</span>

        <span class="cov8" title="1">*o = slice

        return nil</span>
}

// CricketTeamExistsG checks if the CricketTeam row exists.
func CricketTeamExistsG(ctx context.Context, teamID int) (bool, error) <span class="cov0" title="0">{
        return CricketTeamExists(ctx, boil.GetContextDB(), teamID)
}</span>

// CricketTeamExists checks if the CricketTeam row exists.
func CricketTeamExists(ctx context.Context, exec boil.ContextExecutor, teamID int) (bool, error) <span class="cov8" title="1">{
        var exists bool
        sql := "select exists(select 1 from \"cricket_teams\" where \"team_id\"=$1 limit 1)"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, teamID)
        }</span>
        <span class="cov8" title="1">row := exec.QueryRowContext(ctx, sql, teamID)

        err := row.Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: unable to check if cricket_teams exists")
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// Exists checks if the CricketTeam row exists.
func (o *CricketTeam) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        return CricketTeamExists(ctx, exec, o.TeamID)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "context"
        "database/sql"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/friendsofgo/errors"
        "github.com/volatiletech/null/v8"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
        "github.com/volatiletech/strmangle"
)

// Migration is an object representing the database table.
type Migration struct {
        ID        string    `boil:"id" json:"id" toml:"id" yaml:"id"`
        AppliedAt null.Time `boil:"applied_at" json:"applied_at,omitempty" toml:"applied_at" yaml:"applied_at,omitempty"`

        R *migrationR `boil:"-" json:"-" toml:"-" yaml:"-"`
        L migrationL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MigrationColumns = struct {
        ID        string
        AppliedAt string
}{
        ID:        "id",
        AppliedAt: "applied_at",
}

var MigrationTableColumns = struct {
        ID        string
        AppliedAt string
}{
        ID:        "migrations.id",
        AppliedAt: "migrations.applied_at",
}

// Generated where

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, false, x)
}</span>
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, true, x)
}</span>
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>

func (w whereHelpernull_Time) IsNull() qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.WhereIsNull(w.field) }</span>
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod <span class="cov0" title="0">{ return qmhelper.WhereIsNotNull(w.field) }</span>

var MigrationWhere = struct {
        ID        whereHelperstring
        AppliedAt whereHelpernull_Time
}{
        ID:        whereHelperstring{field: "\"migrations\".\"id\""},
        AppliedAt: whereHelpernull_Time{field: "\"migrations\".\"applied_at\""},
}

// MigrationRels is where relationship names are stored.
var MigrationRels = struct {
}{}

// migrationR is where relationships are stored.
type migrationR struct {
}

// NewStruct creates a new relationship struct
func (*migrationR) NewStruct() *migrationR <span class="cov0" title="0">{
        return &amp;migrationR{}
}</span>

// migrationL is where Load methods for each relationship are stored.
type migrationL struct{}

var (
        migrationAllColumns            = []string{"id", "applied_at"}
        migrationColumnsWithoutDefault = []string{"id"}
        migrationColumnsWithDefault    = []string{"applied_at"}
        migrationPrimaryKeyColumns     = []string{"id"}
        migrationGeneratedColumns      = []string{}
)

type (
        // MigrationSlice is an alias for a slice of pointers to Migration.
        // This should almost always be used instead of []Migration.
        MigrationSlice []*Migration
        // MigrationHook is the signature for custom Migration hook methods
        MigrationHook func(context.Context, boil.ContextExecutor, *Migration) error

        migrationQuery struct {
                *queries.Query
        }
)

// Cache for insert, update and upsert
var (
        migrationType                 = reflect.TypeOf(&amp;Migration{})
        migrationMapping              = queries.MakeStructMapping(migrationType)
        migrationPrimaryKeyMapping, _ = queries.BindMapping(migrationType, migrationMapping, migrationPrimaryKeyColumns)
        migrationInsertCacheMut       sync.RWMutex
        migrationInsertCache          = make(map[string]insertCache)
        migrationUpdateCacheMut       sync.RWMutex
        migrationUpdateCache          = make(map[string]updateCache)
        migrationUpsertCacheMut       sync.RWMutex
        migrationUpsertCache          = make(map[string]insertCache)
)

var (
        // Force time package dependency for automated UpdatedAt/CreatedAt.
        _ = time.Second
        // Force qmhelper dependency for where clause generation (which doesn't
        // always happen)
        _ = qmhelper.Where
)

var migrationAfterSelectHooks []MigrationHook

var migrationBeforeInsertHooks []MigrationHook
var migrationAfterInsertHooks []MigrationHook

var migrationBeforeUpdateHooks []MigrationHook
var migrationAfterUpdateHooks []MigrationHook

var migrationBeforeDeleteHooks []MigrationHook
var migrationAfterDeleteHooks []MigrationHook

var migrationBeforeUpsertHooks []MigrationHook
var migrationAfterUpsertHooks []MigrationHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Migration) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range migrationAfterSelectHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Migration) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range migrationBeforeInsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Migration) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range migrationAfterInsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Migration) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range migrationBeforeUpdateHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Migration) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range migrationAfterUpdateHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Migration) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range migrationBeforeDeleteHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Migration) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range migrationAfterDeleteHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Migration) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range migrationBeforeUpsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Migration) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range migrationAfterUpsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// AddMigrationHook registers your hook function for all future operations.
func AddMigrationHook(hookPoint boil.HookPoint, migrationHook MigrationHook) <span class="cov8" title="1">{
        switch hookPoint </span>{
        case boil.AfterSelectHook:<span class="cov8" title="1">
                migrationAfterSelectHooks = append(migrationAfterSelectHooks, migrationHook)</span>
        case boil.BeforeInsertHook:<span class="cov8" title="1">
                migrationBeforeInsertHooks = append(migrationBeforeInsertHooks, migrationHook)</span>
        case boil.AfterInsertHook:<span class="cov8" title="1">
                migrationAfterInsertHooks = append(migrationAfterInsertHooks, migrationHook)</span>
        case boil.BeforeUpdateHook:<span class="cov8" title="1">
                migrationBeforeUpdateHooks = append(migrationBeforeUpdateHooks, migrationHook)</span>
        case boil.AfterUpdateHook:<span class="cov8" title="1">
                migrationAfterUpdateHooks = append(migrationAfterUpdateHooks, migrationHook)</span>
        case boil.BeforeDeleteHook:<span class="cov8" title="1">
                migrationBeforeDeleteHooks = append(migrationBeforeDeleteHooks, migrationHook)</span>
        case boil.AfterDeleteHook:<span class="cov8" title="1">
                migrationAfterDeleteHooks = append(migrationAfterDeleteHooks, migrationHook)</span>
        case boil.BeforeUpsertHook:<span class="cov8" title="1">
                migrationBeforeUpsertHooks = append(migrationBeforeUpsertHooks, migrationHook)</span>
        case boil.AfterUpsertHook:<span class="cov8" title="1">
                migrationAfterUpsertHooks = append(migrationAfterUpsertHooks, migrationHook)</span>
        }
}

// OneG returns a single migration record from the query using the global executor.
func (q migrationQuery) OneG(ctx context.Context) (*Migration, error) <span class="cov0" title="0">{
        return q.One(ctx, boil.GetContextDB())
}</span>

// One returns a single migration record from the query.
func (q migrationQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Migration, error) <span class="cov8" title="1">{
        o := &amp;Migration{}

        queries.SetLimit(q.Query, 1)

        err := q.Bind(ctx, exec, o)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: failed to execute a one query for migrations")</span>
        }

        <span class="cov8" title="1">if err := o.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return o, err
        }</span>

        <span class="cov8" title="1">return o, nil</span>
}

// AllG returns all Migration records from the query using the global executor.
func (q migrationQuery) AllG(ctx context.Context) (MigrationSlice, error) <span class="cov0" title="0">{
        return q.All(ctx, boil.GetContextDB())
}</span>

// All returns all Migration records from the query.
func (q migrationQuery) All(ctx context.Context, exec boil.ContextExecutor) (MigrationSlice, error) <span class="cov8" title="1">{
        var o []*Migration

        err := q.Bind(ctx, exec, &amp;o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "models: failed to assign all query results to Migration slice")
        }</span>

        <span class="cov8" title="1">if len(migrationAfterSelectHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return o, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return o, nil</span>
}

// CountG returns the count of all Migration records in the query using the global executor
func (q migrationQuery) CountG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return q.Count(ctx, boil.GetContextDB())
}</span>

// Count returns the count of all Migration records in the query.
func (q migrationQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to count migrations rows")
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// ExistsG checks if the row exists in the table using the global executor.
func (q migrationQuery) ExistsG(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return q.Exists(ctx, boil.GetContextDB())
}</span>

// Exists checks if the row exists in the table.
func (q migrationQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)
        queries.SetLimit(q.Query, 1)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: failed to check if migrations exists")
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// Migrations retrieves all the records using an executor.
func Migrations(mods ...qm.QueryMod) migrationQuery <span class="cov8" title="1">{
        mods = append(mods, qm.From("\"migrations\""))
        q := NewQuery(mods...)
        if len(queries.GetSelect(q)) == 0 </span><span class="cov8" title="1">{
                queries.SetSelect(q, []string{"\"migrations\".*"})
        }</span>

        <span class="cov8" title="1">return migrationQuery{q}</span>
}

// FindMigrationG retrieves a single record by ID.
func FindMigrationG(ctx context.Context, iD string, selectCols ...string) (*Migration, error) <span class="cov0" title="0">{
        return FindMigration(ctx, boil.GetContextDB(), iD, selectCols...)
}</span>

// FindMigration retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMigration(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Migration, error) <span class="cov8" title="1">{
        migrationObj := &amp;Migration{}

        sel := "*"
        if len(selectCols) &gt; 0 </span><span class="cov0" title="0">{
                sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf(
                "select %s from \"migrations\" where \"id\"=$1", sel,
        )

        q := queries.Raw(query, iD)

        err := q.Bind(ctx, exec, migrationObj)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: unable to select from migrations")</span>
        }

        <span class="cov8" title="1">if err = migrationObj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return migrationObj, err
        }</span>

        <span class="cov8" title="1">return migrationObj, nil</span>
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Migration) InsertG(ctx context.Context, columns boil.Columns) error <span class="cov0" title="0">{
        return o.Insert(ctx, boil.GetContextDB(), columns)
}</span>

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Migration) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no migrations provided for insertion")
        }</span>

        <span class="cov8" title="1">var err error

        if err := o.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nzDefaults := queries.NonZeroDefaultSet(migrationColumnsWithDefault, o)

        key := makeCacheKey(columns, nzDefaults)
        migrationInsertCacheMut.RLock()
        cache, cached := migrationInsertCache[key]
        migrationInsertCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl, returnColumns := columns.InsertColumnSet(
                        migrationAllColumns,
                        migrationColumnsWithDefault,
                        migrationColumnsWithoutDefault,
                        nzDefaults,
                )

                cache.valueMapping, err = queries.BindMapping(migrationType, migrationMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cache.retMapping, err = queries.BindMapping(migrationType, migrationMapping, returnColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(wl) != 0 </span><span class="cov8" title="1">{
                        cache.query = fmt.Sprintf("INSERT INTO \"migrations\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
                }</span> else<span class="cov0" title="0"> {
                        cache.query = "INSERT INTO \"migrations\" %sDEFAULT VALUES%s"
                }</span>

                <span class="cov8" title="1">var queryOutput, queryReturning string

                if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                        queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)</span>
        }

        <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov8" title="1">if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
        }</span> else<span class="cov0" title="0"> {
                _, err = exec.ExecContext(ctx, cache.query, vals...)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to insert into migrations")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                migrationInsertCacheMut.Lock()
                migrationInsertCache[key] = cache
                migrationInsertCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return o.doAfterInsertHooks(ctx, exec)</span>
}

// UpdateG a single Migration record using the global executor.
// See Update for more documentation.
func (o *Migration) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        return o.Update(ctx, boil.GetContextDB(), columns)
}</span>

// Update uses an executor to update the Migration.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Migration) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov8" title="1">{
        var err error
        if err = o.doBeforeUpdateHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">key := makeCacheKey(columns, nil)
        migrationUpdateCacheMut.RLock()
        cache, cached := migrationUpdateCache[key]
        migrationUpdateCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl := columns.UpdateColumnSet(
                        migrationAllColumns,
                        migrationPrimaryKeyColumns,
                )

                if !columns.IsWhitelist() </span><span class="cov8" title="1">{
                        wl = strmangle.SetComplement(wl, []string{"created_at"})
                }</span>
                <span class="cov8" title="1">if len(wl) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("models: unable to update migrations, could not build whitelist")
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf("UPDATE \"migrations\" SET %s WHERE %s",
                        strmangle.SetParamNames("\"", "\"", 1, wl),
                        strmangle.WhereClause("\"", "\"", len(wl)+1, migrationPrimaryKeyColumns),
                )
                cache.valueMapping, err = queries.BindMapping(migrationType, migrationMapping, append(wl, migrationPrimaryKeyColumns...))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, values)
        }</span>
        <span class="cov8" title="1">var result sql.Result
        result, err = exec.ExecContext(ctx, cache.query, values...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update migrations row")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by update for migrations")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                migrationUpdateCacheMut.Lock()
                migrationUpdateCache[key] = cache
                migrationUpdateCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return rowsAff, o.doAfterUpdateHooks(ctx, exec)</span>
}

// UpdateAllG updates all rows with the specified column values.
func (q migrationQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) <span class="cov0" title="0">{
        return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}</span>

// UpdateAll updates all rows with the specified column values.
func (q migrationQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        queries.SetUpdate(q.Query, cols)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all for migrations")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected for migrations")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// UpdateAllG updates all rows with the specified column values.
func (o MigrationSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) <span class="cov0" title="0">{
        return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}</span>

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MigrationSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov8" title="1">{
        ln := int64(len(o))
        if ln == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if len(cols) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: update all requires at least one column argument")
        }</span>

        <span class="cov8" title="1">colNames := make([]string, len(cols))
        args := make([]interface{}, len(cols))

        i := 0
        for name, value := range cols </span><span class="cov8" title="1">{
                colNames[i] = name
                args[i] = value
                i++
        }</span>

        // Append all of the primary key values for each column
        <span class="cov8" title="1">for _, obj := range o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), migrationPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := fmt.Sprintf("UPDATE \"migrations\" SET %s WHERE %s",
                strmangle.SetParamNames("\"", "\"", 1, colNames),
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, migrationPrimaryKeyColumns, len(o)))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all in migration slice")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all migration")
        }</span>
        <span class="cov8" title="1">return rowsAff, nil</span>
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Migration) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error <span class="cov0" title="0">{
        return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}</span>

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Migration) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no migrations provided for upsert")
        }</span>

        <span class="cov8" title="1">if err := o.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nzDefaults := queries.NonZeroDefaultSet(migrationColumnsWithDefault, o)

        // Build cache key in-line uglily - mysql vs psql problems
        buf := strmangle.GetBuffer()
        if updateOnConflict </span><span class="cov8" title="1">{
                buf.WriteByte('t')
        }</span> else<span class="cov8" title="1"> {
                buf.WriteByte('f')
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        for _, c := range conflictColumns </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(updateColumns.Kind))
        for _, c := range updateColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(insertColumns.Kind))
        for _, c := range insertColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">buf.WriteByte('.')
        for _, c := range nzDefaults </span><span class="cov8" title="1">{
                buf.WriteString(c)
        }</span>
        <span class="cov8" title="1">key := buf.String()
        strmangle.PutBuffer(buf)

        migrationUpsertCacheMut.RLock()
        cache, cached := migrationUpsertCache[key]
        migrationUpsertCacheMut.RUnlock()

        var err error

        if !cached </span><span class="cov8" title="1">{
                insert, ret := insertColumns.InsertColumnSet(
                        migrationAllColumns,
                        migrationColumnsWithDefault,
                        migrationColumnsWithoutDefault,
                        nzDefaults,
                )

                update := updateColumns.UpdateColumnSet(
                        migrationAllColumns,
                        migrationPrimaryKeyColumns,
                )

                if updateOnConflict &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                        return errors.New("models: unable to upsert migrations, could not build update column list")
                }</span>

                <span class="cov8" title="1">conflict := conflictColumns
                if len(conflict) == 0 </span><span class="cov8" title="1">{
                        conflict = make([]string, len(migrationPrimaryKeyColumns))
                        copy(conflict, migrationPrimaryKeyColumns)
                }</span>
                <span class="cov8" title="1">cache.query = buildUpsertQueryPostgres(dialect, "\"migrations\"", updateOnConflict, ret, update, conflict, insert)

                cache.valueMapping, err = queries.BindMapping(migrationType, migrationMapping, insert)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(ret) != 0 </span><span class="cov0" title="0">{
                        cache.retMapping, err = queries.BindMapping(migrationType, migrationMapping, ret)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)
        var returns []interface{}
        if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                returns = queries.PtrsFromMapping(value, cache.retMapping)
        }</span>

        <span class="cov8" title="1">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov8" title="1">if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = nil // Postgres doesn't return anything when there's no update
                }</span>
        } else<span class="cov8" title="1"> {
                _, err = exec.ExecContext(ctx, cache.query, vals...)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to upsert migrations")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                migrationUpsertCacheMut.Lock()
                migrationUpsertCache[key] = cache
                migrationUpsertCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return o.doAfterUpsertHooks(ctx, exec)</span>
}

// DeleteG deletes a single Migration record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Migration) DeleteG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return o.Delete(ctx, boil.GetContextDB())
}</span>

// Delete deletes a single Migration record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Migration) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no Migration provided for delete")
        }</span>

        <span class="cov8" title="1">if err := o.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), migrationPrimaryKeyMapping)
        sql := "DELETE FROM \"migrations\" WHERE \"id\"=$1"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete from migrations")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by delete for migrations")
        }</span>

        <span class="cov8" title="1">if err := o.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return rowsAff, nil</span>
}

func (q migrationQuery) DeleteAllG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return q.DeleteAll(ctx, boil.GetContextDB())
}</span>

// DeleteAll deletes all matching rows.
func (q migrationQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if q.Query == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no migrationQuery provided for delete all")
        }</span>

        <span class="cov8" title="1">queries.SetDelete(q.Query)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from migrations")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for migrations")
        }</span>

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// DeleteAllG deletes all rows in the slice.
func (o MigrationSlice) DeleteAllG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return o.DeleteAll(ctx, boil.GetContextDB())
}</span>

// DeleteAll deletes all rows in the slice, using an executor.
func (o MigrationSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if len(migrationBeforeDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov8" title="1">var args []interface{}
        for _, obj := range o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), migrationPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := "DELETE FROM \"migrations\" WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, migrationPrimaryKeyColumns, len(o))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from migration slice")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for migrations")
        }</span>

        <span class="cov8" title="1">if len(migrationAfterDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Migration) ReloadG(ctx context.Context) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no Migration provided for reload")
        }</span>

        <span class="cov0" title="0">return o.Reload(ctx, boil.GetContextDB())</span>
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Migration) Reload(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        ret, err := FindMigration(ctx, exec, o.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*o = *ret
        return nil</span>
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MigrationSlice) ReloadAllG(ctx context.Context) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: empty MigrationSlice provided for reload all")
        }</span>

        <span class="cov0" title="0">return o.ReloadAll(ctx, boil.GetContextDB())</span>
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MigrationSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        if o == nil || len(*o) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">slice := MigrationSlice{}
        var args []interface{}
        for _, obj := range *o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), migrationPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := "SELECT \"migrations\".* FROM \"migrations\" WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, migrationPrimaryKeyColumns, len(*o))

        q := queries.Raw(sql, args...)

        err := q.Bind(ctx, exec, &amp;slice)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to reload all in MigrationSlice")
        }</span>

        <span class="cov8" title="1">*o = slice

        return nil</span>
}

// MigrationExistsG checks if the Migration row exists.
func MigrationExistsG(ctx context.Context, iD string) (bool, error) <span class="cov0" title="0">{
        return MigrationExists(ctx, boil.GetContextDB(), iD)
}</span>

// MigrationExists checks if the Migration row exists.
func MigrationExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) <span class="cov8" title="1">{
        var exists bool
        sql := "select exists(select 1 from \"migrations\" where \"id\"=$1 limit 1)"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, iD)
        }</span>
        <span class="cov8" title="1">row := exec.QueryRowContext(ctx, sql, iD)

        err := row.Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: unable to check if migrations exists")
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// Exists checks if the Migration row exists.
func (o *Migration) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        return MigrationExists(ctx, exec, o.ID)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "fmt"
        "strings"

        "github.com/volatiletech/sqlboiler/v4/drivers"
        "github.com/volatiletech/strmangle"
)

// buildUpsertQueryPostgres builds a SQL statement string using the upsertData provided.
func buildUpsertQueryPostgres(dia drivers.Dialect, tableName string, updateOnConflict bool, ret, update, conflict, whitelist []string) string <span class="cov8" title="1">{
        conflict = strmangle.IdentQuoteSlice(dia.LQ, dia.RQ, conflict)
        whitelist = strmangle.IdentQuoteSlice(dia.LQ, dia.RQ, whitelist)
        ret = strmangle.IdentQuoteSlice(dia.LQ, dia.RQ, ret)

        buf := strmangle.GetBuffer()
        defer strmangle.PutBuffer(buf)

        columns := "DEFAULT VALUES"
        if len(whitelist) != 0 </span><span class="cov8" title="1">{
                columns = fmt.Sprintf("(%s) VALUES (%s)",
                        strings.Join(whitelist, ", "),
                        strmangle.Placeholders(dia.UseIndexPlaceholders, len(whitelist), 1, 1))
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(
                buf,
                "INSERT INTO %s %s ON CONFLICT ",
                tableName,
                columns,
        )

        buf.WriteByte('(')
        buf.WriteString(strings.Join(conflict, ", "))

        if !updateOnConflict || len(update) == 0 </span><span class="cov8" title="1">{
                buf.WriteString(") DO NOTHING")
        }</span> else<span class="cov8" title="1"> {
                buf.WriteString(") DO UPDATE SET ")

                for i, v := range update </span><span class="cov8" title="1">{
                        if len(v) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if i != 0 </span><span class="cov8" title="1">{
                                buf.WriteByte(',')
                        }</span>
                        <span class="cov8" title="1">quoted := strmangle.IdentQuote(dia.LQ, dia.RQ, v)
                        buf.WriteString(quoted)
                        buf.WriteString(" = EXCLUDED.")
                        buf.WriteString(quoted)</span>
                }
        }

        <span class="cov8" title="1">if len(ret) != 0 </span><span class="cov8" title="1">{
                buf.WriteString(" RETURNING ")
                buf.WriteString(strings.Join(ret, ", "))
        }</span>

        <span class="cov8" title="1">return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "context"
        "database/sql"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/friendsofgo/errors"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
        "github.com/volatiletech/strmangle"
)

// TeamPlayer is an object representing the database table.
type TeamPlayer struct {
        PlayerID    int       `boil:"player_id" json:"player_id" toml:"player_id" yaml:"player_id"`
        TeamID      int       `boil:"team_id" json:"team_id" toml:"team_id" yaml:"team_id"`
        JoiningDate time.Time `boil:"joining_date" json:"joining_date" toml:"joining_date" yaml:"joining_date"`

        R *teamPlayerR `boil:"-" json:"-" toml:"-" yaml:"-"`
        L teamPlayerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TeamPlayerColumns = struct {
        PlayerID    string
        TeamID      string
        JoiningDate string
}{
        PlayerID:    "player_id",
        TeamID:      "team_id",
        JoiningDate: "joining_date",
}

var TeamPlayerTableColumns = struct {
        PlayerID    string
        TeamID      string
        JoiningDate string
}{
        PlayerID:    "team_players.player_id",
        TeamID:      "team_players.team_id",
        JoiningDate: "team_players.joining_date",
}

// Generated where

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.EQ, x)
}</span>
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.NEQ, x)
}</span>
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>

var TeamPlayerWhere = struct {
        PlayerID    whereHelperint
        TeamID      whereHelperint
        JoiningDate whereHelpertime_Time
}{
        PlayerID:    whereHelperint{field: "\"team_players\".\"player_id\""},
        TeamID:      whereHelperint{field: "\"team_players\".\"team_id\""},
        JoiningDate: whereHelpertime_Time{field: "\"team_players\".\"joining_date\""},
}

// TeamPlayerRels is where relationship names are stored.
var TeamPlayerRels = struct {
        Player string
        Team   string
}{
        Player: "Player",
        Team:   "Team",
}

// teamPlayerR is where relationships are stored.
type teamPlayerR struct {
        Player *CricketPlayer `boil:"Player" json:"Player" toml:"Player" yaml:"Player"`
        Team   *CricketTeam   `boil:"Team" json:"Team" toml:"Team" yaml:"Team"`
}

// NewStruct creates a new relationship struct
func (*teamPlayerR) NewStruct() *teamPlayerR <span class="cov0" title="0">{
        return &amp;teamPlayerR{}
}</span>

func (r *teamPlayerR) GetPlayer() *CricketPlayer <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.Player</span>
}

func (r *teamPlayerR) GetTeam() *CricketTeam <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.Team</span>
}

// teamPlayerL is where Load methods for each relationship are stored.
type teamPlayerL struct{}

var (
        teamPlayerAllColumns            = []string{"player_id", "team_id", "joining_date"}
        teamPlayerColumnsWithoutDefault = []string{"player_id", "team_id", "joining_date"}
        teamPlayerColumnsWithDefault    = []string{}
        teamPlayerPrimaryKeyColumns     = []string{"player_id", "team_id", "joining_date"}
        teamPlayerGeneratedColumns      = []string{}
)

type (
        // TeamPlayerSlice is an alias for a slice of pointers to TeamPlayer.
        // This should almost always be used instead of []TeamPlayer.
        TeamPlayerSlice []*TeamPlayer
        // TeamPlayerHook is the signature for custom TeamPlayer hook methods
        TeamPlayerHook func(context.Context, boil.ContextExecutor, *TeamPlayer) error

        teamPlayerQuery struct {
                *queries.Query
        }
)

// Cache for insert, update and upsert
var (
        teamPlayerType                 = reflect.TypeOf(&amp;TeamPlayer{})
        teamPlayerMapping              = queries.MakeStructMapping(teamPlayerType)
        teamPlayerPrimaryKeyMapping, _ = queries.BindMapping(teamPlayerType, teamPlayerMapping, teamPlayerPrimaryKeyColumns)
        teamPlayerInsertCacheMut       sync.RWMutex
        teamPlayerInsertCache          = make(map[string]insertCache)
        teamPlayerUpdateCacheMut       sync.RWMutex
        teamPlayerUpdateCache          = make(map[string]updateCache)
        teamPlayerUpsertCacheMut       sync.RWMutex
        teamPlayerUpsertCache          = make(map[string]insertCache)
)

var (
        // Force time package dependency for automated UpdatedAt/CreatedAt.
        _ = time.Second
        // Force qmhelper dependency for where clause generation (which doesn't
        // always happen)
        _ = qmhelper.Where
)

var teamPlayerAfterSelectHooks []TeamPlayerHook

var teamPlayerBeforeInsertHooks []TeamPlayerHook
var teamPlayerAfterInsertHooks []TeamPlayerHook

var teamPlayerBeforeUpdateHooks []TeamPlayerHook
var teamPlayerAfterUpdateHooks []TeamPlayerHook

var teamPlayerBeforeDeleteHooks []TeamPlayerHook
var teamPlayerAfterDeleteHooks []TeamPlayerHook

var teamPlayerBeforeUpsertHooks []TeamPlayerHook
var teamPlayerAfterUpsertHooks []TeamPlayerHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *TeamPlayer) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range teamPlayerAfterSelectHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *TeamPlayer) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range teamPlayerBeforeInsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *TeamPlayer) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range teamPlayerAfterInsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *TeamPlayer) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range teamPlayerBeforeUpdateHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *TeamPlayer) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range teamPlayerAfterUpdateHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *TeamPlayer) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range teamPlayerBeforeDeleteHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *TeamPlayer) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range teamPlayerAfterDeleteHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *TeamPlayer) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range teamPlayerBeforeUpsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *TeamPlayer) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range teamPlayerAfterUpsertHooks </span><span class="cov8" title="1">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// AddTeamPlayerHook registers your hook function for all future operations.
func AddTeamPlayerHook(hookPoint boil.HookPoint, teamPlayerHook TeamPlayerHook) <span class="cov8" title="1">{
        switch hookPoint </span>{
        case boil.AfterSelectHook:<span class="cov8" title="1">
                teamPlayerAfterSelectHooks = append(teamPlayerAfterSelectHooks, teamPlayerHook)</span>
        case boil.BeforeInsertHook:<span class="cov8" title="1">
                teamPlayerBeforeInsertHooks = append(teamPlayerBeforeInsertHooks, teamPlayerHook)</span>
        case boil.AfterInsertHook:<span class="cov8" title="1">
                teamPlayerAfterInsertHooks = append(teamPlayerAfterInsertHooks, teamPlayerHook)</span>
        case boil.BeforeUpdateHook:<span class="cov8" title="1">
                teamPlayerBeforeUpdateHooks = append(teamPlayerBeforeUpdateHooks, teamPlayerHook)</span>
        case boil.AfterUpdateHook:<span class="cov8" title="1">
                teamPlayerAfterUpdateHooks = append(teamPlayerAfterUpdateHooks, teamPlayerHook)</span>
        case boil.BeforeDeleteHook:<span class="cov8" title="1">
                teamPlayerBeforeDeleteHooks = append(teamPlayerBeforeDeleteHooks, teamPlayerHook)</span>
        case boil.AfterDeleteHook:<span class="cov8" title="1">
                teamPlayerAfterDeleteHooks = append(teamPlayerAfterDeleteHooks, teamPlayerHook)</span>
        case boil.BeforeUpsertHook:<span class="cov8" title="1">
                teamPlayerBeforeUpsertHooks = append(teamPlayerBeforeUpsertHooks, teamPlayerHook)</span>
        case boil.AfterUpsertHook:<span class="cov8" title="1">
                teamPlayerAfterUpsertHooks = append(teamPlayerAfterUpsertHooks, teamPlayerHook)</span>
        }
}

// OneG returns a single teamPlayer record from the query using the global executor.
func (q teamPlayerQuery) OneG(ctx context.Context) (*TeamPlayer, error) <span class="cov0" title="0">{
        return q.One(ctx, boil.GetContextDB())
}</span>

// One returns a single teamPlayer record from the query.
func (q teamPlayerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*TeamPlayer, error) <span class="cov8" title="1">{
        o := &amp;TeamPlayer{}

        queries.SetLimit(q.Query, 1)

        err := q.Bind(ctx, exec, o)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: failed to execute a one query for team_players")</span>
        }

        <span class="cov8" title="1">if err := o.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return o, err
        }</span>

        <span class="cov8" title="1">return o, nil</span>
}

// AllG returns all TeamPlayer records from the query using the global executor.
func (q teamPlayerQuery) AllG(ctx context.Context) (TeamPlayerSlice, error) <span class="cov0" title="0">{
        return q.All(ctx, boil.GetContextDB())
}</span>

// All returns all TeamPlayer records from the query.
func (q teamPlayerQuery) All(ctx context.Context, exec boil.ContextExecutor) (TeamPlayerSlice, error) <span class="cov8" title="1">{
        var o []*TeamPlayer

        err := q.Bind(ctx, exec, &amp;o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "models: failed to assign all query results to TeamPlayer slice")
        }</span>

        <span class="cov8" title="1">if len(teamPlayerAfterSelectHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return o, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return o, nil</span>
}

// CountG returns the count of all TeamPlayer records in the query using the global executor
func (q teamPlayerQuery) CountG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return q.Count(ctx, boil.GetContextDB())
}</span>

// Count returns the count of all TeamPlayer records in the query.
func (q teamPlayerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to count team_players rows")
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// ExistsG checks if the row exists in the table using the global executor.
func (q teamPlayerQuery) ExistsG(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return q.Exists(ctx, boil.GetContextDB())
}</span>

// Exists checks if the row exists in the table.
func (q teamPlayerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)
        queries.SetLimit(q.Query, 1)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: failed to check if team_players exists")
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// Player pointed to by the foreign key.
func (o *TeamPlayer) Player(mods ...qm.QueryMod) cricketPlayerQuery <span class="cov8" title="1">{
        queryMods := []qm.QueryMod{
                qm.Where("\"player_id\" = ?", o.PlayerID),
        }

        queryMods = append(queryMods, mods...)

        return CricketPlayers(queryMods...)
}</span>

// Team pointed to by the foreign key.
func (o *TeamPlayer) Team(mods ...qm.QueryMod) cricketTeamQuery <span class="cov8" title="1">{
        queryMods := []qm.QueryMod{
                qm.Where("\"team_id\" = ?", o.TeamID),
        }

        queryMods = append(queryMods, mods...)

        return CricketTeams(queryMods...)
}</span>

// LoadPlayer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (teamPlayerL) LoadPlayer(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTeamPlayer interface{}, mods queries.Applicator) error <span class="cov8" title="1">{
        var slice []*TeamPlayer
        var object *TeamPlayer

        if singular </span><span class="cov8" title="1">{
                var ok bool
                object, ok = maybeTeamPlayer.(*TeamPlayer)
                if !ok </span><span class="cov0" title="0">{
                        object = new(TeamPlayer)
                        ok = queries.SetFromEmbeddedStruct(&amp;object, &amp;maybeTeamPlayer)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeTeamPlayer))
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                s, ok := maybeTeamPlayer.(*[]*TeamPlayer)
                if ok </span><span class="cov8" title="1">{
                        slice = *s
                }</span> else<span class="cov0" title="0"> {
                        ok = queries.SetFromEmbeddedStruct(&amp;slice, maybeTeamPlayer)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeTeamPlayer))
                        }</span>
                }
        }

        <span class="cov8" title="1">args := make([]interface{}, 0, 1)
        if singular </span><span class="cov8" title="1">{
                if object.R == nil </span><span class="cov0" title="0">{
                        object.R = &amp;teamPlayerR{}
                }</span>
                <span class="cov8" title="1">args = append(args, object.PlayerID)</span>

        } else<span class="cov8" title="1"> {
        Outer:
                for _, obj := range slice </span><span class="cov8" title="1">{
                        if obj.R == nil </span><span class="cov8" title="1">{
                                obj.R = &amp;teamPlayerR{}
                        }</span>

                        <span class="cov8" title="1">for _, a := range args </span><span class="cov0" title="0">{
                                if a == obj.PlayerID </span><span class="cov0" title="0">{
                                        continue Outer</span>
                                }
                        }

                        <span class="cov8" title="1">args = append(args, obj.PlayerID)</span>

                }
        }

        <span class="cov8" title="1">if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">query := NewQuery(
                qm.From(`cricket_players`),
                qm.WhereIn(`cricket_players.player_id in ?`, args...),
        )
        if mods != nil </span><span class="cov0" title="0">{
                mods.Apply(query)
        }</span>

        <span class="cov8" title="1">results, err := query.QueryContext(ctx, e)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to eager load CricketPlayer")
        }</span>

        <span class="cov8" title="1">var resultSlice []*CricketPlayer
        if err = queries.Bind(results, &amp;resultSlice); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to bind eager loaded slice CricketPlayer")
        }</span>

        <span class="cov8" title="1">if err = results.Close(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to close results of eager load for cricket_players")
        }</span>
        <span class="cov8" title="1">if err = results.Err(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error occurred during iteration of eager loaded relations for cricket_players")
        }</span>

        <span class="cov8" title="1">if len(cricketPlayerAfterSelectHooks) != 0 </span><span class="cov8" title="1">{
                for _, obj := range resultSlice </span><span class="cov8" title="1">{
                        if err := obj.doAfterSelectHooks(ctx, e); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(resultSlice) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if singular </span><span class="cov8" title="1">{
                foreign := resultSlice[0]
                object.R.Player = foreign
                if foreign.R == nil </span><span class="cov8" title="1">{
                        foreign.R = &amp;cricketPlayerR{}
                }</span>
                <span class="cov8" title="1">foreign.R.PlayerTeamPlayers = append(foreign.R.PlayerTeamPlayers, object)
                return nil</span>
        }

        <span class="cov8" title="1">for _, local := range slice </span><span class="cov8" title="1">{
                for _, foreign := range resultSlice </span><span class="cov8" title="1">{
                        if local.PlayerID == foreign.PlayerID </span><span class="cov8" title="1">{
                                local.R.Player = foreign
                                if foreign.R == nil </span><span class="cov8" title="1">{
                                        foreign.R = &amp;cricketPlayerR{}
                                }</span>
                                <span class="cov8" title="1">foreign.R.PlayerTeamPlayers = append(foreign.R.PlayerTeamPlayers, local)
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// LoadTeam allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (teamPlayerL) LoadTeam(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTeamPlayer interface{}, mods queries.Applicator) error <span class="cov8" title="1">{
        var slice []*TeamPlayer
        var object *TeamPlayer

        if singular </span><span class="cov8" title="1">{
                var ok bool
                object, ok = maybeTeamPlayer.(*TeamPlayer)
                if !ok </span><span class="cov0" title="0">{
                        object = new(TeamPlayer)
                        ok = queries.SetFromEmbeddedStruct(&amp;object, &amp;maybeTeamPlayer)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeTeamPlayer))
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                s, ok := maybeTeamPlayer.(*[]*TeamPlayer)
                if ok </span><span class="cov8" title="1">{
                        slice = *s
                }</span> else<span class="cov0" title="0"> {
                        ok = queries.SetFromEmbeddedStruct(&amp;slice, maybeTeamPlayer)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeTeamPlayer))
                        }</span>
                }
        }

        <span class="cov8" title="1">args := make([]interface{}, 0, 1)
        if singular </span><span class="cov8" title="1">{
                if object.R == nil </span><span class="cov0" title="0">{
                        object.R = &amp;teamPlayerR{}
                }</span>
                <span class="cov8" title="1">args = append(args, object.TeamID)</span>

        } else<span class="cov8" title="1"> {
        Outer:
                for _, obj := range slice </span><span class="cov8" title="1">{
                        if obj.R == nil </span><span class="cov8" title="1">{
                                obj.R = &amp;teamPlayerR{}
                        }</span>

                        <span class="cov8" title="1">for _, a := range args </span><span class="cov0" title="0">{
                                if a == obj.TeamID </span><span class="cov0" title="0">{
                                        continue Outer</span>
                                }
                        }

                        <span class="cov8" title="1">args = append(args, obj.TeamID)</span>

                }
        }

        <span class="cov8" title="1">if len(args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">query := NewQuery(
                qm.From(`cricket_teams`),
                qm.WhereIn(`cricket_teams.team_id in ?`, args...),
        )
        if mods != nil </span><span class="cov0" title="0">{
                mods.Apply(query)
        }</span>

        <span class="cov8" title="1">results, err := query.QueryContext(ctx, e)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to eager load CricketTeam")
        }</span>

        <span class="cov8" title="1">var resultSlice []*CricketTeam
        if err = queries.Bind(results, &amp;resultSlice); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to bind eager loaded slice CricketTeam")
        }</span>

        <span class="cov8" title="1">if err = results.Close(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to close results of eager load for cricket_teams")
        }</span>
        <span class="cov8" title="1">if err = results.Err(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error occurred during iteration of eager loaded relations for cricket_teams")
        }</span>

        <span class="cov8" title="1">if len(cricketTeamAfterSelectHooks) != 0 </span><span class="cov8" title="1">{
                for _, obj := range resultSlice </span><span class="cov8" title="1">{
                        if err := obj.doAfterSelectHooks(ctx, e); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(resultSlice) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if singular </span><span class="cov8" title="1">{
                foreign := resultSlice[0]
                object.R.Team = foreign
                if foreign.R == nil </span><span class="cov8" title="1">{
                        foreign.R = &amp;cricketTeamR{}
                }</span>
                <span class="cov8" title="1">foreign.R.TeamTeamPlayers = append(foreign.R.TeamTeamPlayers, object)
                return nil</span>
        }

        <span class="cov8" title="1">for _, local := range slice </span><span class="cov8" title="1">{
                for _, foreign := range resultSlice </span><span class="cov8" title="1">{
                        if local.TeamID == foreign.TeamID </span><span class="cov8" title="1">{
                                local.R.Team = foreign
                                if foreign.R == nil </span><span class="cov8" title="1">{
                                        foreign.R = &amp;cricketTeamR{}
                                }</span>
                                <span class="cov8" title="1">foreign.R.TeamTeamPlayers = append(foreign.R.TeamTeamPlayers, local)
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// SetPlayerG of the teamPlayer to the related item.
// Sets o.R.Player to related.
// Adds o to related.R.PlayerTeamPlayers.
// Uses the global database handle.
func (o *TeamPlayer) SetPlayerG(ctx context.Context, insert bool, related *CricketPlayer) error <span class="cov0" title="0">{
        return o.SetPlayer(ctx, boil.GetContextDB(), insert, related)
}</span>

// SetPlayer of the teamPlayer to the related item.
// Sets o.R.Player to related.
// Adds o to related.R.PlayerTeamPlayers.
func (o *TeamPlayer) SetPlayer(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CricketPlayer) error <span class="cov8" title="1">{
        var err error
        if insert </span><span class="cov8" title="1">{
                if err = related.Insert(ctx, exec, boil.Infer()); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to insert into foreign table")
                }</span>
        }

        <span class="cov8" title="1">updateQuery := fmt.Sprintf(
                "UPDATE \"team_players\" SET %s WHERE %s",
                strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
                strmangle.WhereClause("\"", "\"", 2, teamPlayerPrimaryKeyColumns),
        )
        values := []interface{}{related.PlayerID, o.PlayerID, o.TeamID, o.JoiningDate}

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, updateQuery)
                fmt.Fprintln(writer, values)
        }</span>
        <span class="cov8" title="1">if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to update local table")
        }</span>

        <span class="cov8" title="1">o.PlayerID = related.PlayerID
        if o.R == nil </span><span class="cov8" title="1">{
                o.R = &amp;teamPlayerR{
                        Player: related,
                }
        }</span> else<span class="cov8" title="1"> {
                o.R.Player = related
        }</span>

        <span class="cov8" title="1">if related.R == nil </span><span class="cov8" title="1">{
                related.R = &amp;cricketPlayerR{
                        PlayerTeamPlayers: TeamPlayerSlice{o},
                }
        }</span> else<span class="cov0" title="0"> {
                related.R.PlayerTeamPlayers = append(related.R.PlayerTeamPlayers, o)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SetTeamG of the teamPlayer to the related item.
// Sets o.R.Team to related.
// Adds o to related.R.TeamTeamPlayers.
// Uses the global database handle.
func (o *TeamPlayer) SetTeamG(ctx context.Context, insert bool, related *CricketTeam) error <span class="cov0" title="0">{
        return o.SetTeam(ctx, boil.GetContextDB(), insert, related)
}</span>

// SetTeam of the teamPlayer to the related item.
// Sets o.R.Team to related.
// Adds o to related.R.TeamTeamPlayers.
func (o *TeamPlayer) SetTeam(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CricketTeam) error <span class="cov8" title="1">{
        var err error
        if insert </span><span class="cov8" title="1">{
                if err = related.Insert(ctx, exec, boil.Infer()); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to insert into foreign table")
                }</span>
        }

        <span class="cov8" title="1">updateQuery := fmt.Sprintf(
                "UPDATE \"team_players\" SET %s WHERE %s",
                strmangle.SetParamNames("\"", "\"", 1, []string{"team_id"}),
                strmangle.WhereClause("\"", "\"", 2, teamPlayerPrimaryKeyColumns),
        )
        values := []interface{}{related.TeamID, o.PlayerID, o.TeamID, o.JoiningDate}

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, updateQuery)
                fmt.Fprintln(writer, values)
        }</span>
        <span class="cov8" title="1">if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to update local table")
        }</span>

        <span class="cov8" title="1">o.TeamID = related.TeamID
        if o.R == nil </span><span class="cov8" title="1">{
                o.R = &amp;teamPlayerR{
                        Team: related,
                }
        }</span> else<span class="cov8" title="1"> {
                o.R.Team = related
        }</span>

        <span class="cov8" title="1">if related.R == nil </span><span class="cov8" title="1">{
                related.R = &amp;cricketTeamR{
                        TeamTeamPlayers: TeamPlayerSlice{o},
                }
        }</span> else<span class="cov0" title="0"> {
                related.R.TeamTeamPlayers = append(related.R.TeamTeamPlayers, o)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// TeamPlayers retrieves all the records using an executor.
func TeamPlayers(mods ...qm.QueryMod) teamPlayerQuery <span class="cov8" title="1">{
        mods = append(mods, qm.From("\"team_players\""))
        q := NewQuery(mods...)
        if len(queries.GetSelect(q)) == 0 </span><span class="cov8" title="1">{
                queries.SetSelect(q, []string{"\"team_players\".*"})
        }</span>

        <span class="cov8" title="1">return teamPlayerQuery{q}</span>
}

// FindTeamPlayerG retrieves a single record by ID.
func FindTeamPlayerG(ctx context.Context, playerID int, teamID int, joiningDate time.Time, selectCols ...string) (*TeamPlayer, error) <span class="cov0" title="0">{
        return FindTeamPlayer(ctx, boil.GetContextDB(), playerID, teamID, joiningDate, selectCols...)
}</span>

// FindTeamPlayer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTeamPlayer(ctx context.Context, exec boil.ContextExecutor, playerID int, teamID int, joiningDate time.Time, selectCols ...string) (*TeamPlayer, error) <span class="cov8" title="1">{
        teamPlayerObj := &amp;TeamPlayer{}

        sel := "*"
        if len(selectCols) &gt; 0 </span><span class="cov0" title="0">{
                sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf(
                "select %s from \"team_players\" where \"player_id\"=$1 AND \"team_id\"=$2 AND \"joining_date\"=$3", sel,
        )

        q := queries.Raw(query, playerID, teamID, joiningDate)

        err := q.Bind(ctx, exec, teamPlayerObj)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: unable to select from team_players")</span>
        }

        <span class="cov8" title="1">if err = teamPlayerObj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return teamPlayerObj, err
        }</span>

        <span class="cov8" title="1">return teamPlayerObj, nil</span>
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *TeamPlayer) InsertG(ctx context.Context, columns boil.Columns) error <span class="cov0" title="0">{
        return o.Insert(ctx, boil.GetContextDB(), columns)
}</span>

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *TeamPlayer) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no team_players provided for insertion")
        }</span>

        <span class="cov8" title="1">var err error

        if err := o.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nzDefaults := queries.NonZeroDefaultSet(teamPlayerColumnsWithDefault, o)

        key := makeCacheKey(columns, nzDefaults)
        teamPlayerInsertCacheMut.RLock()
        cache, cached := teamPlayerInsertCache[key]
        teamPlayerInsertCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl, returnColumns := columns.InsertColumnSet(
                        teamPlayerAllColumns,
                        teamPlayerColumnsWithDefault,
                        teamPlayerColumnsWithoutDefault,
                        nzDefaults,
                )

                cache.valueMapping, err = queries.BindMapping(teamPlayerType, teamPlayerMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cache.retMapping, err = queries.BindMapping(teamPlayerType, teamPlayerMapping, returnColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(wl) != 0 </span><span class="cov8" title="1">{
                        cache.query = fmt.Sprintf("INSERT INTO \"team_players\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
                }</span> else<span class="cov0" title="0"> {
                        cache.query = "INSERT INTO \"team_players\" %sDEFAULT VALUES%s"
                }</span>

                <span class="cov8" title="1">var queryOutput, queryReturning string

                if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                        queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)</span>
        }

        <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov8" title="1">if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
        }</span> else<span class="cov8" title="1"> {
                _, err = exec.ExecContext(ctx, cache.query, vals...)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to insert into team_players")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                teamPlayerInsertCacheMut.Lock()
                teamPlayerInsertCache[key] = cache
                teamPlayerInsertCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return o.doAfterInsertHooks(ctx, exec)</span>
}

// UpdateG a single TeamPlayer record using the global executor.
// See Update for more documentation.
func (o *TeamPlayer) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        return o.Update(ctx, boil.GetContextDB(), columns)
}</span>

// Update uses an executor to update the TeamPlayer.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *TeamPlayer) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        var err error
        if err = o.doBeforeUpdateHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">key := makeCacheKey(columns, nil)
        teamPlayerUpdateCacheMut.RLock()
        cache, cached := teamPlayerUpdateCache[key]
        teamPlayerUpdateCacheMut.RUnlock()

        if !cached </span><span class="cov0" title="0">{
                wl := columns.UpdateColumnSet(
                        teamPlayerAllColumns,
                        teamPlayerPrimaryKeyColumns,
                )

                if !columns.IsWhitelist() </span><span class="cov0" title="0">{
                        wl = strmangle.SetComplement(wl, []string{"created_at"})
                }</span>
                <span class="cov0" title="0">if len(wl) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("models: unable to update team_players, could not build whitelist")
                }</span>

                <span class="cov0" title="0">cache.query = fmt.Sprintf("UPDATE \"team_players\" SET %s WHERE %s",
                        strmangle.SetParamNames("\"", "\"", 1, wl),
                        strmangle.WhereClause("\"", "\"", len(wl)+1, teamPlayerPrimaryKeyColumns),
                )
                cache.valueMapping, err = queries.BindMapping(teamPlayerType, teamPlayerMapping, append(wl, teamPlayerPrimaryKeyColumns...))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov0" title="0">values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, values)
        }</span>
        <span class="cov0" title="0">var result sql.Result
        result, err = exec.ExecContext(ctx, cache.query, values...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update team_players row")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by update for team_players")
        }</span>

        <span class="cov0" title="0">if !cached </span><span class="cov0" title="0">{
                teamPlayerUpdateCacheMut.Lock()
                teamPlayerUpdateCache[key] = cache
                teamPlayerUpdateCacheMut.Unlock()
        }</span>

        <span class="cov0" title="0">return rowsAff, o.doAfterUpdateHooks(ctx, exec)</span>
}

// UpdateAllG updates all rows with the specified column values.
func (q teamPlayerQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) <span class="cov0" title="0">{
        return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}</span>

// UpdateAll updates all rows with the specified column values.
func (q teamPlayerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        queries.SetUpdate(q.Query, cols)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all for team_players")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected for team_players")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// UpdateAllG updates all rows with the specified column values.
func (o TeamPlayerSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) <span class="cov0" title="0">{
        return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}</span>

// UpdateAll updates all rows with the specified column values, using an executor.
func (o TeamPlayerSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        ln := int64(len(o))
        if ln == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">if len(cols) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: update all requires at least one column argument")
        }</span>

        <span class="cov0" title="0">colNames := make([]string, len(cols))
        args := make([]interface{}, len(cols))

        i := 0
        for name, value := range cols </span><span class="cov0" title="0">{
                colNames[i] = name
                args[i] = value
                i++
        }</span>

        // Append all of the primary key values for each column
        <span class="cov0" title="0">for _, obj := range o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), teamPlayerPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := fmt.Sprintf("UPDATE \"team_players\" SET %s WHERE %s",
                strmangle.SetParamNames("\"", "\"", 1, colNames),
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, teamPlayerPrimaryKeyColumns, len(o)))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all in teamPlayer slice")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all teamPlayer")
        }</span>
        <span class="cov0" title="0">return rowsAff, nil</span>
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *TeamPlayer) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error <span class="cov0" title="0">{
        return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}</span>

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *TeamPlayer) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no team_players provided for upsert")
        }</span>

        <span class="cov0" title="0">if err := o.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nzDefaults := queries.NonZeroDefaultSet(teamPlayerColumnsWithDefault, o)

        // Build cache key in-line uglily - mysql vs psql problems
        buf := strmangle.GetBuffer()
        if updateOnConflict </span><span class="cov0" title="0">{
                buf.WriteByte('t')
        }</span> else<span class="cov0" title="0"> {
                buf.WriteByte('f')
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        for _, c := range conflictColumns </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(updateColumns.Kind))
        for _, c := range updateColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(insertColumns.Kind))
        for _, c := range insertColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        for _, c := range nzDefaults </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">key := buf.String()
        strmangle.PutBuffer(buf)

        teamPlayerUpsertCacheMut.RLock()
        cache, cached := teamPlayerUpsertCache[key]
        teamPlayerUpsertCacheMut.RUnlock()

        var err error

        if !cached </span><span class="cov0" title="0">{
                insert, ret := insertColumns.InsertColumnSet(
                        teamPlayerAllColumns,
                        teamPlayerColumnsWithDefault,
                        teamPlayerColumnsWithoutDefault,
                        nzDefaults,
                )

                update := updateColumns.UpdateColumnSet(
                        teamPlayerAllColumns,
                        teamPlayerPrimaryKeyColumns,
                )

                if updateOnConflict &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                        return errors.New("models: unable to upsert team_players, could not build update column list")
                }</span>

                <span class="cov0" title="0">conflict := conflictColumns
                if len(conflict) == 0 </span><span class="cov0" title="0">{
                        conflict = make([]string, len(teamPlayerPrimaryKeyColumns))
                        copy(conflict, teamPlayerPrimaryKeyColumns)
                }</span>
                <span class="cov0" title="0">cache.query = buildUpsertQueryPostgres(dialect, "\"team_players\"", updateOnConflict, ret, update, conflict, insert)

                cache.valueMapping, err = queries.BindMapping(teamPlayerType, teamPlayerMapping, insert)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(ret) != 0 </span><span class="cov0" title="0">{
                        cache.retMapping, err = queries.BindMapping(teamPlayerType, teamPlayerMapping, ret)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)
        var returns []interface{}
        if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                returns = queries.PtrsFromMapping(value, cache.retMapping)
        }</span>

        <span class="cov0" title="0">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov0" title="0">if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = nil // Postgres doesn't return anything when there's no update
                }</span>
        } else<span class="cov0" title="0"> {
                _, err = exec.ExecContext(ctx, cache.query, vals...)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to upsert team_players")
        }</span>

        <span class="cov0" title="0">if !cached </span><span class="cov0" title="0">{
                teamPlayerUpsertCacheMut.Lock()
                teamPlayerUpsertCache[key] = cache
                teamPlayerUpsertCacheMut.Unlock()
        }</span>

        <span class="cov0" title="0">return o.doAfterUpsertHooks(ctx, exec)</span>
}

// DeleteG deletes a single TeamPlayer record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *TeamPlayer) DeleteG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return o.Delete(ctx, boil.GetContextDB())
}</span>

// Delete deletes a single TeamPlayer record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *TeamPlayer) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no TeamPlayer provided for delete")
        }</span>

        <span class="cov8" title="1">if err := o.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), teamPlayerPrimaryKeyMapping)
        sql := "DELETE FROM \"team_players\" WHERE \"player_id\"=$1 AND \"team_id\"=$2 AND \"joining_date\"=$3"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete from team_players")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by delete for team_players")
        }</span>

        <span class="cov8" title="1">if err := o.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return rowsAff, nil</span>
}

func (q teamPlayerQuery) DeleteAllG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return q.DeleteAll(ctx, boil.GetContextDB())
}</span>

// DeleteAll deletes all matching rows.
func (q teamPlayerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if q.Query == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no teamPlayerQuery provided for delete all")
        }</span>

        <span class="cov8" title="1">queries.SetDelete(q.Query)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from team_players")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for team_players")
        }</span>

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// DeleteAllG deletes all rows in the slice.
func (o TeamPlayerSlice) DeleteAllG(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        return o.DeleteAll(ctx, boil.GetContextDB())
}</span>

// DeleteAll deletes all rows in the slice, using an executor.
func (o TeamPlayerSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if len(teamPlayerBeforeDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov8" title="1">var args []interface{}
        for _, obj := range o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), teamPlayerPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := "DELETE FROM \"team_players\" WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, teamPlayerPrimaryKeyColumns, len(o))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from teamPlayer slice")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for team_players")
        }</span>

        <span class="cov8" title="1">if len(teamPlayerAfterDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// ReloadG refetches the object from the database using the primary keys.
func (o *TeamPlayer) ReloadG(ctx context.Context) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no TeamPlayer provided for reload")
        }</span>

        <span class="cov0" title="0">return o.Reload(ctx, boil.GetContextDB())</span>
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *TeamPlayer) Reload(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        ret, err := FindTeamPlayer(ctx, exec, o.PlayerID, o.TeamID, o.JoiningDate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*o = *ret
        return nil</span>
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TeamPlayerSlice) ReloadAllG(ctx context.Context) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: empty TeamPlayerSlice provided for reload all")
        }</span>

        <span class="cov0" title="0">return o.ReloadAll(ctx, boil.GetContextDB())</span>
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TeamPlayerSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        if o == nil || len(*o) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">slice := TeamPlayerSlice{}
        var args []interface{}
        for _, obj := range *o </span><span class="cov8" title="1">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), teamPlayerPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov8" title="1">sql := "SELECT \"team_players\".* FROM \"team_players\" WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, teamPlayerPrimaryKeyColumns, len(*o))

        q := queries.Raw(sql, args...)

        err := q.Bind(ctx, exec, &amp;slice)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to reload all in TeamPlayerSlice")
        }</span>

        <span class="cov8" title="1">*o = slice

        return nil</span>
}

// TeamPlayerExistsG checks if the TeamPlayer row exists.
func TeamPlayerExistsG(ctx context.Context, playerID int, teamID int, joiningDate time.Time) (bool, error) <span class="cov0" title="0">{
        return TeamPlayerExists(ctx, boil.GetContextDB(), playerID, teamID, joiningDate)
}</span>

// TeamPlayerExists checks if the TeamPlayer row exists.
func TeamPlayerExists(ctx context.Context, exec boil.ContextExecutor, playerID int, teamID int, joiningDate time.Time) (bool, error) <span class="cov8" title="1">{
        var exists bool
        sql := "select exists(select 1 from \"team_players\" where \"player_id\"=$1 AND \"team_id\"=$2 AND \"joining_date\"=$3 limit 1)"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, playerID, teamID, joiningDate)
        }</span>
        <span class="cov8" title="1">row := exec.QueryRowContext(ctx, sql, playerID, teamID, joiningDate)

        err := row.Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: unable to check if team_players exists")
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// Exists checks if the TeamPlayer row exists.
func (o *TeamPlayer) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        return TeamPlayerExists(ctx, exec, o.PlayerID, o.TeamID, o.JoiningDate)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"

        "github.com/sports-dynamics/cricket-fever/internal/validation"

        "go.uber.org/zap"
)

type ErrorResponse struct {
        Code    string        `json:"code"`
        Message string        `json:"message"`
        Target  string        `json:"target,omitempty"`
        Details []ErrorDetail `json:"details,omitempty"`
}

type ErrorDetail struct {
        Code    string `json:"code"`
        Target  string `json:"target,omitempty"`
        Message string `json:"message"`
}

func RespondWithError(ctx context.Context, w http.ResponseWriter, err error, fallbackStatusCode int) <span class="cov8" title="1">{
        var errResponse ErrorResponse
        var appError validation.AppError
        if errors.As(err, &amp;appError) </span><span class="cov8" title="1">{
                errResponse.Code = appError.ErrorCode()
                errResponse.Message = appError.Message()
                errResponse.Target = appError.Target()
                errResponse.Details = makeErrorDetails(appError.Details())
        }</span> else<span class="cov8" title="1"> {
                errResponse.Code = validation.ErrCodeFallback
                errResponse.Message = err.Error()

        }</span>
        <span class="cov8" title="1">w.WriteHeader(mapErrorToHttpStatus(err, fallbackStatusCode))
        if err := json.NewEncoder(w).Encode(errResponse); err != nil </span><span class="cov0" title="0">{
                zap.Error(errors.New("Could not encode error response" + err.Error()))
        }</span>
}

func makeErrorDetails(errorArray []error) []ErrorDetail <span class="cov8" title="1">{
        var details []ErrorDetail
        for _, err := range errorArray </span><span class="cov8" title="1">{
                var appError validation.AppError
                var detail ErrorDetail
                if errors.As(err, &amp;appError) </span><span class="cov0" title="0">{
                        detail.Code = appError.ErrorCode()
                        detail.Target = appError.Target()
                        detail.Message = appError.Message()
                }</span> else<span class="cov8" title="1"> {
                        detail.Code = validation.ErrCodeFallback
                        detail.Message = err.Error()
                }</span>
                <span class="cov8" title="1">details = append(details, detail)</span>
        }
        <span class="cov8" title="1">return details</span>
}

func mapErrorToHttpStatus(err error, fallbackCode int) int <span class="cov8" title="1">{
        var appError validation.AppError
        if errors.As(err, &amp;appError) </span><span class="cov8" title="1">{
                if statusCode, ok := errorCodeToStatusCode[appError.ErrorCode()]; ok </span><span class="cov0" title="0">{
                        return statusCode
                }</span>
        }

        <span class="cov8" title="1">return fallbackCode</span>
}

var errorCodeToStatusCode = map[string]int{
        validation.ErrCodeNotFound:          http.StatusNotFound,
        validation.ErrCodeInvalidInput:      http.StatusBadRequest,
        validation.ErrCodeRequireField:      http.StatusBadRequest,
        validation.ErrCodeDuplicate:         http.StatusConflict,
        validation.ErrCodeForbidden:         http.StatusForbidden,
        validation.ErrCodeInsufficientFunds: http.StatusUnprocessableEntity,
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "net/http"

        "github.com/sports-dynamics/cricket-fever/internal/modo"
        "go.uber.org/zap"
)

// HeartbeatHandler is used to validate the liveness/readiness of this pod
func HeartbeatHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK) // headers must be sent before output, or output sends a default 200 OK header
        if _, err := w.Write([]byte(http.StatusText(http.StatusOK))); err != nil </span><span class="cov0" title="0">{
                modo.Logger(r.Context()).Error("Error writing response.", zap.Error(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"

        "go.uber.org/zap"
)

func RespondWithSuccess(ctx context.Context, w http.ResponseWriter, response any, statusCode int) <span class="cov8" title="1">{
        w.WriteHeader(statusCode)
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                zap.Error(errors.New("encoding failed , err = " + err.Error()))
        }</span>

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "context"
        "net/http"

        "github.com/go-chi/chi/v5/middleware"
        "github.com/sports-dynamics/cricket-fever/internal/handlers"
        "github.com/sports-dynamics/cricket-fever/internal/modo"
        "github.com/sports-dynamics/cricket-fever/internal/validation"
        "go.uber.org/zap"
)

const (
        xApiToken = "X-API-TOKEN"
)

func AuthMiddleware(validApiToken string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        sovApiToken := r.Header.Get(xApiToken)
                        if err := validateApiTokens(sovApiToken, validApiToken); err != nil </span><span class="cov8" title="1">{
                                handlers.RespondWithError(r.Context(), w, err, http.StatusUnauthorized)
                                return
                        }</span>

                        // Create a response writer wrapper to capture the status code
                        <span class="cov8" title="1">rww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        // Call the next handler
                        next.ServeHTTP(rww, r)

                        // Log the response
                        modo.Logger(context.Background()).Info("auth middleware", zap.Int("response status", rww.Status()))</span>
                })
        }
}

func validateApiTokens(apiToken, validApiToken string) error <span class="cov8" title="1">{
        if len(apiToken) == 0 </span><span class="cov8" title="1">{
                return validation.NewAppError(validation.ErrCodeAuthFailed, "unauthorized access , empty api token", xApiToken)
        }</span>
        <span class="cov8" title="1">if apiToken != validApiToken </span><span class="cov8" title="1">{
                return validation.NewAppError(validation.ErrCodeAuthFailed, "unauthorized access , invalid api token", xApiToken)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package players

import (
        "github.com/sports-dynamics/cricket-fever/internal/db/models"
)

type PlayerRequestParams struct {
        models.CricketPlayer
}

func (t *PlayerRequestParams) Validate() error <span class="cov8" title="1">{
        return nil
}</span>

const (
        PlayerUUID string = "PlayerUUID"
)
</pre>
		
		<pre class="file" id="file12" style="display: none">package players

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/sports-dynamics/cricket-fever/internal/handlers"
        "github.com/sports-dynamics/cricket-fever/internal/modo"
        "go.uber.org/zap"
)

type createPlayer struct {
        service PlayerService
}

func CreatePlayerHandler(service PlayerService) http.HandlerFunc <span class="cov8" title="1">{

        return createPlayer{service: service}.ServeHTTP
}</span>

type CreateNewPlayer struct {
}

func (t createPlayer) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var request *PlayerRequestParams

        decoder := json.NewDecoder(r.Body)
        if err := decoder.Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                handlers.RespondWithError(r.Context(), w, err, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        fmt.Println(" dumping value at handler level : ", request)

        if err := request.Validate(); err != nil </span><span class="cov0" title="0">{
                handlers.RespondWithError(r.Context(), w, err, http.StatusUnprocessableEntity)
                return
        }</span>

        <span class="cov8" title="1">team, err := t.service.Create(context.Background(), request)

        if err != nil </span><span class="cov0" title="0">{
                modo.Logger(r.Context()).Error("Could not create account.", zap.Error(err))
                handlers.RespondWithError(r.Context(), w, err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">handlers.RespondWithSuccess(r.Context(), w, team, http.StatusCreated)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package players

import (
        "context"
        "net/http"

        "github.com/sports-dynamics/cricket-fever/internal/handlers"
        "github.com/sports-dynamics/cricket-fever/internal/modo"
        "github.com/sports-dynamics/cricket-fever/internal/utils"
        "go.uber.org/zap"
)

type deletePlayer struct {
        service PlayerService
}

func DeletePlayerHandler(service PlayerService) http.HandlerFunc <span class="cov0" title="0">{

        return createPlayer{service: service}.ServeHTTP
}</span>

func (t deletePlayer) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        uuid, err := utils.GetUUIDFromRequest(r, PlayerUUID)
        if err != nil </span><span class="cov0" title="0">{
                handlers.RespondWithError(r.Context(), w, err, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">team, err := t.service.Delete(context.Background(), uuid)

        if err != nil </span><span class="cov0" title="0">{
                modo.Logger(r.Context()).Error("Could not get player information.", zap.Error(err))
                handlers.RespondWithError(r.Context(), w, err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">handlers.RespondWithSuccess(r.Context(), w, team, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package players

import (
        "context"
        "net/http"

        "github.com/sports-dynamics/cricket-fever/internal/handlers"
        "github.com/sports-dynamics/cricket-fever/internal/modo"
        "github.com/sports-dynamics/cricket-fever/internal/utils"
        "go.uber.org/zap"
)

type getPlayer struct {
        service PlayerService
}

func GetPlayerHandler(service PlayerService) http.HandlerFunc <span class="cov0" title="0">{

        return getPlayer{service: service}.ServeHTTP
}</span>

func (t getPlayer) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        uuid, err := utils.GetUUIDFromRequest(r, PlayerUUID)
        if err != nil </span><span class="cov0" title="0">{
                handlers.RespondWithError(r.Context(), w, err, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">team, err := t.service.Get(context.Background(), uuid)

        if err != nil </span><span class="cov0" title="0">{
                modo.Logger(r.Context()).Error("Could not get player information.", zap.Error(err))
                handlers.RespondWithError(r.Context(), w, err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">handlers.RespondWithSuccess(r.Context(), w, team, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package players

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/sports-dynamics/cricket-fever/internal/handlers"
        "github.com/sports-dynamics/cricket-fever/internal/modo"
        "go.uber.org/zap"
)

type updatePlayer struct {
        service PlayerService
}

func UpdatePlayerHandler(service PlayerService) http.HandlerFunc <span class="cov0" title="0">{

        return createPlayer{service: service}.ServeHTTP
}</span>

func (t updatePlayer) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var request *PlayerRequestParams

        decoder := json.NewDecoder(r.Body)
        if err := decoder.Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                handlers.RespondWithError(r.Context(), w, err, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">defer r.Body.Close()

        if err := request.Validate(); err != nil </span><span class="cov0" title="0">{
                handlers.RespondWithError(r.Context(), w, err, http.StatusUnprocessableEntity)
                return
        }</span>

        <span class="cov0" title="0">team, err := t.service.Update(context.Background(), request)

        if err != nil </span><span class="cov0" title="0">{
                modo.Logger(r.Context()).Error("Could not create account.", zap.Error(err))
                handlers.RespondWithError(r.Context(), w, err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">handlers.RespondWithSuccess(r.Context(), w, team, http.StatusCreated)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package players

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/sports-dynamics/cricket-fever/internal/db/models"
        "github.com/volatiletech/null/v8"
        "github.com/volatiletech/sqlboiler/v4/boil"
)

type PlayerRepo interface {
        Create(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error)
        Get(ctx context.Context, id int) (*models.CricketPlayer, error)
        Update(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error)
        Delete(ctx context.Context, id int) (*models.CricketPlayer, error)
}

type Repo struct {
        db *sql.DB
}

func NewPlayerRepo(db *sql.DB) PlayerRepo <span class="cov0" title="0">{
        return &amp;Repo{db: db}
}</span>

func (ct Repo) Create(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error) <span class="cov0" title="0">{

        fmt.Println("dumping request value : ", req)

        new_team := models.CricketPlayer{
                PlayerName:        req.PlayerName,
                PlayerEmail:       req.PlayerEmail,
                PlayerMobile:      req.PlayerMobile,
                PlayerPicture:     null.BytesFrom(req.PlayerPicture.Bytes),
                PlayerRole:        req.PlayerRole,
                BattingPositions:  req.BattingPositions,
                BowlerTypes:       req.BowlerTypes,
                FieldingPositions: req.FieldingPositions,
        }

        if err := new_team.Insert(context.Background(), ct.db, boil.Infer()); err != nil </span><span class="cov0" title="0">{
                fmt.Println("[players][repo] failed to insert into db : ", err.Error())
                return &amp;new_team, err
        }</span>

        <span class="cov0" title="0">fmt.Println(" new team value : ", new_team)

        return &amp;new_team, nil</span>
}

func (ct Repo) Get(ctx context.Context, playerID int) (*models.CricketPlayer, error) <span class="cov0" title="0">{

        query := models.CricketPlayers(models.CricketTeamWhere.TeamID.EQ(playerID))

        player, err := query.One(ctx, ct.db)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed to fetch particular team from team table : ", err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return player, nil</span>
}

func (ct Repo) Update(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error) <span class="cov0" title="0">{

        player := models.CricketPlayer{PlayerID: req.PlayerID}

        player.Update(ctx, ct.db, boil.Infer())

        return &amp;player, nil
}</span>

func (ct Repo) Delete(ctx context.Context, playerID int) (*models.CricketPlayer, error) <span class="cov0" title="0">{

        player := models.CricketPlayer{PlayerID: playerID}

        player.Delete(ctx, ct.db)

        return &amp;player, nil
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package players

import (
        "context"

        "github.com/sports-dynamics/cricket-fever/internal/db/models"
)

type PlayerService interface {
        Create(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error)
        Get(ctx context.Context, playerUUID string) (*models.CricketPlayer, error)
        Update(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error)
        Delete(ctx context.Context, playerUUID string) (*models.CricketPlayer, error)
}

type newPlayer struct {
        repo PlayerRepo
}

func NewPlayerService(repo PlayerRepo) PlayerService <span class="cov0" title="0">{
        return &amp;newPlayer{repo: repo}
}</span>

func (t *newPlayer) Create(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error) <span class="cov0" title="0">{

        newPlayer, err := t.repo.Create(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return newPlayer, err
        }</span>

        <span class="cov0" title="0">return newPlayer, nil</span>

}
func (t *newPlayer) Get(ctx context.Context, playerUUID string) (*models.CricketPlayer, error) <span class="cov0" title="0">{

        // TO-DO fetch UUID for the player
        newTeam, err := t.repo.Get(ctx, 1)
        if err != nil </span><span class="cov0" title="0">{
                return newTeam, err
        }</span>

        <span class="cov0" title="0">return newTeam, nil</span>

}

func (t *newPlayer) Update(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error) <span class="cov0" title="0">{

        newTeam, err := t.repo.Update(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return newTeam, err
        }</span>

        <span class="cov0" title="0">return newTeam, nil</span>

}

func (t *newPlayer) Delete(ctx context.Context, playerUUID string) (*models.CricketPlayer, error) <span class="cov0" title="0">{

        // TO-DO fetch UUID for the player
        newTeam, err := t.repo.Delete(ctx, 1)
        if err != nil </span><span class="cov0" title="0">{
                return newTeam, err
        }</span>

        <span class="cov0" title="0">return newTeam, nil</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">package players

import (
        "context"

        "github.com/sports-dynamics/cricket-fever/internal/db/models"
)

type PlayerStubs struct {
        CreatFunc  func(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error)
        GetFunc    func(ctx context.Context, playerUUID string) (*models.CricketPlayer, error)
        UpdateFunc func(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error)
        DeleteFunc func(ctx context.Context, playerUUID string) (*models.CricketPlayer, error)
}

var _ PlayerService = (*PlayerStubs)(nil)

func (s PlayerStubs) Create(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error) <span class="cov8" title="1">{
        if s.CreatFunc != nil </span><span class="cov8" title="1">{
                return s.CreatFunc(ctx, req)
        }</span>
        <span class="cov0" title="0">panic("Unexpected call to CreateTeam stub")</span>
}

func (s PlayerStubs) Get(ctx context.Context, playerUUID string) (*models.CricketPlayer, error) <span class="cov0" title="0">{
        if s.GetFunc != nil </span><span class="cov0" title="0">{
                return s.GetFunc(ctx, playerUUID)
        }</span>
        <span class="cov0" title="0">panic("Unexpected call to CreateTeam stub")</span>
}
func (s PlayerStubs) Update(ctx context.Context, req *PlayerRequestParams) (*models.CricketPlayer, error) <span class="cov0" title="0">{
        if s.UpdateFunc != nil </span><span class="cov0" title="0">{
                return s.UpdateFunc(ctx, req)
        }</span>
        <span class="cov0" title="0">panic("Unexpected call to CreateTeam stub")</span>
}

func (s PlayerStubs) Delete(ctx context.Context, playerUUID string) (*models.CricketPlayer, error) <span class="cov0" title="0">{
        if s.DeleteFunc != nil </span><span class="cov0" title="0">{
                return s.DeleteFunc(ctx, playerUUID)
        }</span>
        <span class="cov0" title="0">panic("Unexpected call to CreateTeam stub")</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package validation

import "fmt"

type AppError interface {
        ErrorCode() string
        Message() string
        Details() []error
        Target() string
        error
}

const (
        ErrCodeRequireField            = "ErrCodeRequiredField"
        ErrCodeNotFound                = "ErrCodeNotFound"
        ErrCodeInvalidInput            = "ErrCodeInvalidInput"
        ErrCodeValidation              = "ErrCodeValidation"
        ErrCodeRuleRequired            = "ErrCodeRuleRequired"
        ErrCodeRuleDuplicate           = "ErrCodeRuleDuplicate"
        ErrCodeRuleInvalidValue        = "ErrCodeRuleInvalidValue"
        ErrCodeRuleInvalidType         = "ErrCodeRuleInvalidType"
        ErrCodeInvalidLength           = "ErrCodeInvalidLength"
        ErrCodeDuplicate               = "ErrCodeDuplicate"
        ErrCodeFallback                = "ErrCodeFallback"
        ErrCodeAuthFailed              = "ErrCodeAuthFailed"
        ErrCodeForbidden               = "ErrCodeForbidden"
        ErrCodeRuleViolation           = "ErrCodeRuleViolation"
        ErrCodeInsufficientFunds       = "ErrCodeInsufficientFunds"
        ErrCodeInvalidRequestParameter = "ErrCodeInvalidRequestParameter"
)

func NewAppError(code string, msg string, target string) AppError <span class="cov8" title="1">{
        return baseAppError{code: code, msg: msg, target: target}
}</span>

func NewNotFoundError(msg string) AppError <span class="cov8" title="1">{
        return baseAppError{code: ErrCodeNotFound, msg: msg, target: ""}
}</span>

func NewRequiredFieldError(field string) AppError <span class="cov8" title="1">{
        return baseAppError{code: ErrCodeRequireField, msg: fmt.Sprintf("'%s' is a required field", field), target: field}
}</span>

func NewInsufficientFundsError(target string) AppError <span class="cov0" title="0">{
        return baseAppError{code: ErrCodeInsufficientFunds, msg: "Insufficient funds, the requested amount exceeds the available balance", target: target}
}</span>

type baseAppError struct {
        code   string
        msg    string
        target string
}

func (b baseAppError) ErrorCode() string <span class="cov8" title="1">{
        return b.code
}</span>

func (b baseAppError) Message() string <span class="cov8" title="1">{
        return b.msg
}</span>

func (b baseAppError) Details() []error <span class="cov8" title="1">{
        return nil
}</span>

func (b baseAppError) Target() string <span class="cov8" title="1">{
        return b.target
}</span>

func (b baseAppError) Error() string <span class="cov8" title="1">{
        return b.msg
}</span>

var _ AppError = (*baseAppError)(nil)
</pre>
		
		<pre class="file" id="file20" style="display: none">package validation

import (
        "fmt"
        "strings"
)

type MultiError struct {
        Errors []error
        Reason string
        Code   string
}

var _ AppError = (*MultiError)(nil)

func (e MultiError) ErrorCode() string <span class="cov8" title="1">{
        return e.Code
}</span>

func (e MultiError) HasErrors() bool <span class="cov8" title="1">{
        return len(e.Errors) &gt; 0
}</span>

func (e MultiError) Message() string <span class="cov8" title="1">{
        return e.Reason
}</span>

func (e MultiError) Details() []error <span class="cov8" title="1">{
        return e.Errors
}</span>

func (e MultiError) Target() string <span class="cov8" title="1">{
        return ""
}</span>

func (e MultiError) Error() string <span class="cov8" title="1">{
        errorMessages := make([]string, len(e.Errors))
        for i, err := range e.Errors </span><span class="cov8" title="1">{
                errorMessages[i] = err.Error()
        }</span>
        <span class="cov8" title="1">allErrors := strings.Join(errorMessages, "; ")

        if e.Message() != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %s", e.Reason, allErrors)
        }</span>

        <span class="cov8" title="1">return allErrors</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
